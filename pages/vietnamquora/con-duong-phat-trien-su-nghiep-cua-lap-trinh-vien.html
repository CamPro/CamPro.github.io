<div>#wednonquora<br>#IT #Programming #ComputerScience #Career<br>CON ĐƯỜNG PHÁT TRIỂN SỰ NGHIỆP CỦA LẬP TRÌNH VIÊN <br>(Mình vừa trans cái này bên reddit xong, nhận ra hôm nay là thứ tư, nên bưng qua đây vậy, đằng nào bài này cũng khá có ích 🤣)<br><br>r/learnprogramming<br>u/KTStephano (770 points)<br><br>Edit: Level cuối cùng sẽ có tên là "Tốt nghiệp / Sau Tốt nghiệp". Thực ra level này sẽ gây tranh cãi cho nhiều người nhưng kệ họ đi, post này không dành cho những senior nhiều năm kinh nghiệm trong ngành. Đối tượng của post này là những sinh viên CS (Computer Science), về những thứ mà họ sẽ được tiếp xúc.<br><br>Edit 2: Level "Advanced" sẽ được đổi thành "Junior". Tôi thấy cái này hợp hơn.<br><br>Xin chào, trước khi bắt đầu, tôi phải nói trước đây không phải là con đường duy nhất. Tôi chỉ hy vọng nó sẽ có ích cho những ai đang tự học, có đam mê hay đang muốn đổi ngành, về những gì họ nên biết để có thể cạnh tranh với những người đã được đào tạo CS bài bản. Nó cũng sẽ có ích với những ai muốn học trước chương trình, hoặc những ai đang không biết liệu skill của mình đang ở mức nào.<br><br>Source bài này: tổng hợp của kinh nghiệm cá nhân tôi, những gì tôi được dạy trong trường lớp, những gì tôi tự học ngoài trường lớp, và những gì tôi thấy được trong quá trình làm việc.<br><br>#############################<br><br>NHỮNG NGÔN NGỮ PHỔ BIẾN TRONG TRƯỜNG ĐẠI HỌC<br><br>Những ngôn ngữ này thường được dạy trong các trường đại học. Tất nhiên là bạn không cần phải biết tất, nhưng bởi tôi thấy rất nhiều người hỏi "Nên học ngôn ngữ nào giờ?". Câu trả lời là chả có cái nào cố định hết, chả có course nào tập trung vào dạy một ngôn ngữ nào cụ thể cả, ngôn ngữ chỉ là một công cụ mà thôi. Thực tế thì các trường đại học thường chọn những ngôn ngữ phù hợp nhất với những lĩnh vực cụ thể mà họ đào tạo.<br><br>+ Java/C#: Thường được dạy để giới thiệu về những thứ liên quan tới OOP - lập trình hướng đối tượng<br><br>+ C/C++: Dạy cách quản lý bộ nhớ, vì cả 2 thằng này đều không có hệ thống garbage collector. Ngoài ra còn dùng nhiều trong các course Kiến trúc Máy tính / Hệ điều hành<br><br>+ Assembly: Dạy trong Kiến trúc Máy tính, minh hoạ quá trình dịch code C thành một loại code low level hơn trước khi được dịch tiếp thành mã máy<br><br>+ Python: Rất phổ biến trong các course giới thiệu lập trình căn bản, ngoài ra còn được dùng nhiều trong các course AI và ML (Machine Learning)<br><br>+ Scheme/Haskell: Giúp làm quen với concept lập trình hàm (Functional Programming) hoặc lập trình khai báo (Declarative Programming), cũng như minh hoạ concept đệ quy cho người mới<br><br>+ JavaScript: Các course về web development, ngoài ra cũng có vài course lập trình căn bản bằng JS, vì cái này không phải cài gì cả, chạy được trên mọi web browser<br><br>+ Matlab: Nếu bạn muốn đào sâu về tính toán số học (Numerical Computing) thì học cái này<br><br>Như trên, nếu các bạn cứ chỉ tập trung vào học ngôn ngữ, thì rất có thể các bạn sẽ vô tình bị học trùng (T/N: ý tác giả: ngôn ngữ chỉ là công cụ, chọn cái phù hợp nhất với mục đích của mình, đừng chỉ chăm chăm học ngôn ngữ mà quên đi mục đích của ngôn ngữ là hỗ trợ công việc thôi)<br><br>#############################<br><br>QUÁ TRÌNH TIẾN HOÁ TRONG VIỆC SỬ DỤNG NGÔN NGỮ<br><br>Trong phần này tôi sẽ nói về việc người ta thay đổi ra sao trong việc sử dụng ngôn ngữ suốt quá trình học. Khả năng cao bạn sẽ thấy những thứ sắp được nêu có đôi chút giống với bản thân, cho dù bạn có đi theo con đường "truyền thống" hay không.<br><br>+ Trước tốt nghiệp level thấp: Tốn thời gian chọn ra ngôn ngữ phù hợp nhất để giới thiệu lập trình căn bản. Java hoặc Python hay được chọn ở level này. Giảng viên sẽ chỉ định ngôn ngữ cho bạn, và tốn nhiều thời gian để giải thích các concept cơ bản.<br><br>+ Trước tốt nghiệp level khá: Không dành nhiều thời gian lắm cho việc giới thiệu các concept cơ bản, nhiều course có thể dạy bạn sử dụng vài ngôn ngữ một lúc nếu họ thấy cần (Scheme + Haskell, C + Assembly, vân vân).<br><br>+ Cận tốt nghiệp / trước cao học: Thường sẽ không còn màn giới thiệu. Professor sẽ kiểu "Chúng ta sẽ dùng những ngôn ngữ này nhá". Bạn sẽ phải tự học những thứ cơ bản, hoặc thậm chí sẽ là "Course này không giới hạn ngôn ngữ, các em tự chọn cái phù hợp nhất". Bạn sẽ phải đủ kiến thức và kinh nghiệm để tự chọn ra ngôn ngữ phù hợp nhất với mục tiêu công việc.<br><br>Bài học: Đừng quá bám vào một ngôn ngữ nào đó. Học cách "học những thứ mới" cũng là một phần của việc học.<br><br>Giờ tôi sẽ phân loại lập trình viên thành các level. Những phân loại này sẽ giúp bạn biết bạn đang ở mức nào, và nên học những thứ gì tiếp theo để nâng cao trình độ. Nhưng cũng đừng quan trọng hoá quá việc mình đang ở level nào, tập trung vào cái đích mà bạn nhắm tới ấy.<br><br>#############################<br><br>BEGINNER<br><br>1. Có zero hoặc rất ít kinh nghiệm lập trình. Bạn vừa được tiếp cận với khái niệm "lập trình", mọi thứ đều lạ lẫm đối với bạn.<br><br>2. Bạn chưa hoặc vừa chọn được ngôn ngữ mình muốn theo. Vì có rất nhiều thứ mới phải học, hãy bám vào 1 ngôn ngữ cụ thể cho tới khi cảm thấy tự tin học ngôn ngữ mới.<br><br>3. Luồng điều khiển (Control Flow) còn là một thứ gì đó rất lạ lẫm với bạn. Bạn mất kha khá thời gian để thuần thục if, switch case và các vòng lặp.<br><br>4. Hiếm khi bạn tách code thành các hàm với chức năng chuyên biệt.<br><br>5. Tốn nhiều thời gian ở mục "Getting Started" trong các tutorial<br><br>6. Thường xuyên cảm thấy choáng ngợp và hoang mang vì tất cả mọi thứ đều thật mới mẻ lạ lẫm<br><br>Chương trình lớn nhất từng viết: Cùng lắm là 100 dòng, nhét tất cả vào 1 file<br><br>#############################<br><br>TRUNG CẤP<br><br>1. Hiểu được tại sao cần tách code thành các hàm để tái sử dụng<br><br>2. Bắt đầu làm quen với OOP, hơi biết cách quản lý class, nhưng khoản này với bạn vẫn khá khó khăn<br><br>3. Bắt đầu biết cách quản lý bộ nhớ với những ngôn ngữ không có garbage collector. Phân biệt được heap và stack, hiểu được tại sao phải phân biệt.<br><br>4. Hiểu được đệ quy là gì, nhưng vẫn thấy rất khó khăn để sử dụng đệ quy<br><br>5. Đã được tiếp xúc với các phép toán trên tập hợp và các phép toán logic (T/N: Ở VN cái này được dạy trong môn toán rời rạc - Discrete Math), nền tảng của logic trong lập trình<br><br>6. Đa phần các thao tác thông qua GUI (sử dụng IDE để code, dùng git bằng GUI, etc)<br><br>7. Phần lớn / tất cả dữ liệu của bạn vẫn lưu trong ổ cứng<br><br>8. Bắt đầu khám phá thế giới cấu trúc dữ liệu và giải thuật, sau đó có một sự hoang mang không hề nhẹ<br><br>9. Hiểu việc dạy người khác những gì mình học được là cách củng cố kiến thức tốt nhất. Tận dụng mỗi khi có thể<br><br>10. Bắt đầu biết dùng Make/CMake và các thứ tương tự<br><br>11. Phân biệt được trình thông dịch (Interpreter) và trình biên dịch (Compiler), mặc dù chưa biết vận dụng cả 2<br><br>Chương trình lớn nhất từng viết: Dao động trong khoảng 500 - 1000 dòng code, nhét vào 1-3 file<br><br>#############################<br><br>JUNIOR<br><br>1. Sử dụng command line / terminal tần suất cao. Có được skill này qua việc sử dụng đồng thời nhiều máy tính một lúc (ví dụ Linux shell qua ssh)<br><br>2. Tự động hoá quá trình build và quản lý các thư viện, đặc biệt trong các project lớn<br><br>3. Không còn lưu tất cả trong ổ cứng nữa, chuyển sang dùng cloud. Nếu máy của bạn hỏng thì cũng không ảnh hưởng gì đến dữ liệu ngoại trừ việc phải cài lại IDE / tool chains / compiler<br><br>4. Đã được tiếp xúc với mô hình lập trình hàm / lập trình khai báo. Qua đó thấy được các mô hình này tác động lên cấu trúc các ngôn ngữ bậc cao như Java hay C++ ra sao<br><br>5. Hiểu sâu về vòng lặp và đệ quy, bạn không ngại việc chuyển qua lại và thoải mái chọn ra cái phù hợp nhất để giải quyết vấn đề<br><br>6. Sử dụng thành thạo ít nhất 1 ngôn ngữ, ngoài ra đã nghịch 1-2 cái khác. Bạn thấy được điểm giống nhau giữa các ngôn ngữ bạn biết, và tất nhiên cũng hiểu được chúng khác nhau như thế nào.<br><br>7. Hiểu (hoặc lờ mờ hiểu) về độ phức tạp của bài toán: O(n), O(log(n)), O(nlog(n)), O(n^2), O(2^n), etc.<br><br>8. Hiểu rõ về ưu nhược của các cấu trúc dữ liệu cơ bản: Linked List, Mảng (size cố định và dynamic), Cây, Hash table, Queue và Heap. Qua đó bạn có thể chọn ra loại phù hợp để giải quyết vấn đề<br><br>9. Bạn có hiểu biết về những thuật toán cơ bản và mục đích của chúng: binary search, string search (brute force, KMP, Rabin-Karp), graph search (breadth-first, depth-first, best-first), đường đi ngắn nhất (Dijkstra's, A*), sorting (bubble sort, merge-sort, quicksort). (T/N: và cả heapsort. Heapsort mình thấy cũng rất hay nhưng không thấy được nhắc đến ở đây)<br><br>10. Đã thử dọ dẫm bước vào thế giới của các phần mềm quy mô lớn (T/N: Ý tác giả là nghịch các project open source lớn: Chromium, các OS nhân Unix, etc.). Bạn gặp rất nhiều khó khăn vì mới chỉ gõ 1 hoặc 2 chương trình cỡ nhỏ/vừa, và chưa quen với việc organize code lắm.<br><br>11. Đã thử nghịch điều khiển đa luồng (multithreading) và phát rồ, nhưng ít nhất thì giờ bạn cũng biết là phải cẩn thận với cái thứ này. (T/N: đúng là phải phát rồ với multithreading thật =)) )<br><br>Chương trình lớn nhất từng viết: Vài nghìn dòng code, chia thành nhiều file. Mỗi file tương đương với một tính năng trong app, nhưng thi thoảng có thể bị bloated (thừa, rườm rà) vì bạn chưa quen lắm với việc viết những app lớn.<br><br>#############################<br><br>TỐT NGHIỆP / SAU TỐT NGHIỆP<br><br>* Sau tốt nghiệp bao gồm những nghiên cứu sinh Master/PhD<br><br>1. Đã tiếp xúc với kha khá ngôn ngữ. Học một ngôn ngữ mới với bạn bây giờ không tốn quá nhiều thời gian.<br><br>2. Không chỉ tiếp xúc với nhiều ngôn ngữ, bạn còn không gặp trở ngại gì trong việc chuyển đổi qua lại để chọn ra cái phù hợp nhất với project. Bạn có 1 hoặc 2 ngôn ngữ "tủ", ngoài ra có thể sử dụng thành thạo vài cái khác.<br><br>3. Bạn hiểu được tầm quan trọng của việc viết test toàn diện. Qua đó bạn xác định được liệu tính năng mới code thêm có ảnh hưởng tới các tính năng cũ hay không<br><br>4. Tất cả các app bạn viết đều được tự động hoá quá trình build (build automation). Việc này giúp app của bạn tương thích tốt hơn với đa nền tảng, cũng như cài đặt / khởi động dễ dàng hơn<br><br>5. Đã tiếp xúc với các mẫu kiến trúc phần mềm (T/N: có vẻ ý tác giả là design pattern, như MVC, MVVM, MVP, etc.), sau khi điên đầu với việc quản lý code ở những app đầu tiên. Bạn bỏ thêm thời gian ra để cân nhắc mỗi khi viết một dòng code.<br><br>6. Bạn quen thuộc với việc sử dụng nhiều máy tính, chạy trên nhiều nền tảng khác nhau, nhiều phần cứng khác nhau. "Đa nền tảng" đã ngấm vào máu của bạn, và mỗi khi bạn được dùng một thư viện cho phép đa nền tảng thì cứ như là được ban phước thánh.<br><br>7. Nhân tiện nói về thư viện, bạn không còn tự code mọi thứ nữa. Mỗi khi gặp một vấn đề nào đó thì trước tiên bạn sẽ thử search xem có lib/framework nào sẵn hay không. Nếu tìm thấy thì bạn chả tội gì mà không include vào.<br><br>8. Bạn hiểu những API được viết cẩn thận quan trọng thế nào, nhất là khi sử dụng thư viện(T/N: Tác giả dùng "interface", mình nghĩ ý tác giả là API). Ví dụ, bạn thường xuyên viết những API không bị bó buộc vào một thư viện nhất định, đề phòng sau này có thể phải đổi thư viện cũ sang một cái mới.<br><br>9. Không chỉ hiểu biết sâu về những cấu trúc dữ liệu cơ bản, bạn còn sử dụng những cái xịn hơn như Cây đỏ đen (red-black tree), Hash map hoặc những cấu trúc dữ liệu song song (concurrent data structures). This brought a new respect for professionally-implemented data structures, and showed them some common pitfalls you can run into while trying to create a bullet-proof implementation on your own.<br><br>10. Vẫn thích những project đơn thương độc mã, nhưng bạn hiểu teamwork và giao tiếp quan trọng ra sao. Những project lớn cần rất nhiều nhân lực, không cá nhân nào có thể tự xử lý đơn lẻ được (T/N: "Muốn đi nhanh thì đi một mình, muốn đi xa thì đi cùng nhiều người")<br><br>Chương trình lớn nhất từng viết: >10 000 dòng code, chia thành vô số file, mỗi file phục vụ một và chỉ một mục đích. Giao tiếp giữa các thành phần được thiết kế chỉnh chu, không rối rắm rườm rà (T/N: các cụ hay gọi là spaghetti code). Code viết ra sạch, đúng quy chuẩn.<br><br>#############################<br><br>LEVEL CỦA CỬ NHÂN COMPUTER SCIENCE<br><br>Theo tôi thì bình thường khi tốt nghiệp Bachelor CS, skill mọi người sẽ nằm đâu đó giữa Junior và Tốt nghiệp / Sau Tốt nghiệp. Những trường hợp tốt nghiệp với skill Trung cấp - Junior cũng rất nhiều. Cái này thì tuỳ thuộc vào bạn bỏ ra bao nhiêu công sức học tập (bài vở, đi thực tập, pet project, etc.).<br><br>Thông thường thì để đạt level Tốt nghiệp / Sau Tốt nghiệp và hơn thế, bạn sẽ cần một mớ kinh nghiệm thực chiến trong ít nhất vài năm, làm việc professionally ở các công ty và môi trường teamwork. Còn để tiến xa hơn nữa thì bạn sẽ cần thêm rất nhiều thời gian và công sức cùng với những skill chuyên ngành.<br><br>T/N: Một bài dịch khá dài, cảm ơn các bạn đã đọc và mình xin xin lỗi luôn, level cuối mình dịch hơi bị potato =)) chưa đạt đến level đấy nên chưa thấm được hết ý tác giả, mong các tiền bối chỉ giáo :<<br>____________________<br>Link Reddit: https://redd.it/98ir9p<br><br><img src='https://scontent.fhan17-1.fna.fbcdn.net/v/t1.6435-9/39917991_1712304472224801_3728581248482803712_n.jpg?_nc_cat=105&ccb=1-7&_nc_sid=ca434c&_nc_ohc=k4BGTtlACA8AX_j2rYw&_nc_ht=scontent.fhan17-1.fna&edm=AFuVL-cEAAAA&oh=00_AfB34QZmA9-J85g3MN99i-0EuMZ9er7c3YtQx4PI6BQWvQ&oe=63D0BD2D'></div>