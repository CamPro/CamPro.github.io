<div>462<br>#Windows #WindowsUpdate #WindowsReboot #WindowsRestart #OperatingSystem #Microsoft #vmc<br>Hỏi: Tại sao Windows yêu cầu khởi động lại sau những lần cài đặt cập nhật? Nếu tôi hiểu đúng thì, ta có thể tránh được điều này nếu nhóm phát triển Windows khéo léo tận dụng công nghệ "shadow copy” của họ.<br> <br>Trả lời: Mark Phaedrus, Kỹ sư Phần mềm, Nhóm Windows Update, Microsoft <br>1757 word<br>===========<br>  <br>Nói sơ qua thì, điều này liên quan đến những sở thích của tôi đó.<br> <br>Thế này nhé, đúng rồi đó, update có thể rất khó chịu, và đúng rồi đó, tệ hại lắm luôn, và vâng, tôi xin lỗi cả với tư cách cá nhân lẫn thay mặt cho Microsoft, và vâng, chúng tôi đang tìm cách cải thiện việc này và không có điều gì tôi sắp nói ở đây có thể thay đổi bất kỳ mệnh đề nào vừa rồi.<br> <br>Để giải thích được tại sao những bản shadow copy (SD) không thực sự hữu ích, thì trước tiên, hãy để tôi nói qua SD là cái gì. Về bản chất, SD sẽ cho phép một quá trình nào đó nhận một snapshot của một ổ đĩa (C:, D:, vv) vào bất kỳ thời điểm nào. Trong khi tính năng SD được kích hoạt, những lần ghi vào ổ đĩa đó không ghi đè nên được những nội dung trong đó; thay vào đó, chúng được chuyển tới một vùng đặc biệt trong hệ thống file. Vì vậy nói cách khác, về cơ bản ổ đó đã được chia ra thành hai phần: một phần chứa những nội dung của hệ thống file vào thời điểm yêu cầu SD, và một phần kia giữ tất cả những thay đổi kể từ lúc đó. Thông thường, chương trình tạo ra SD là thứ duy nhất biết được những nội dung chưa được thay đổi của nó. Mọi chương trình khác thường không biết rằng SD đang tồn tại, và chúng thấy được những thay đổi kể từ lúc SD được tạo ra. Đó là bởi khi một trong những chương trình đó nói rằng “Hãy cho tôi dữ liệu trong file X” thì, Windows sẽ bắt đầu với việc đọc phiên bản SD của file X, nhưng rồi sau đó phải kiểm tra xem liệu đã có thay đổi nào chưa; nếu có thì những thay đổi đó phải được thực hiện trước khi chuyển dữ liệu để copy.<br> <br>SD thường được sử dụng cho những sản phẩm backup. Một vấn đề với những chương trình backup của Windows trước khi thực hiện SD ấy là bản backup thi thoảng thiếu nhất quán, vì bản backup chứa phiên bản của những file hiện diện vào thời điểm mà chương trình backup có được nó. Nếu giả sử, bạn đang cài một chương trình khi việc backup đang diễn ra thì, bản backup có thể sẽ chỉ chứa một nửa số file của chương trình đó thôi, và còn rất nhiều kết quả tệ hại khác nữa. Với việc sử dụng SD, một chương trình backup biết rằng nó đang lưu lại một khoảnh khắc tạm thời của hệ thống tại thời điểm đó (thời điểm việc backup diễn ra).<br>  <br>Vì thế nên ngay lập tức sẽ có sự khác biệt giữa cách SD hoạt động và những gì mà Windows Update cần làm. Bản SD đó vẫn không thay đổi gì và thường chỉ một chương trình thấy được điều đó mà thôi. Nhưng Windows Update có lẽ lại muốn làm điều ngược lại - nó sẽ muốn thay đổi thư mục Windows, trong khi mọi chương trình khác chỉ nhìn thấy phiên bản chưa thay đổi của Windows từ lúc bắt đầu update. Chúng ta có thể tạo ra một bản “shadow copy ngược” hoạt động theo cách này; nhưng lại có một vấn đề khác. Hãy nhớ rằng bản SD đó có tác động tới cả ổ đĩa đó, và chia ổ đĩa đó thành “nội dung ổ đĩa hiện tại” và “những thay đổi kể từ lúc đó”. Trong trường hợp Windows Update, Windows sẽ tạo ra những thay đổi mà nó không muốn các chương trình khác thấy, nhưng những chương trình đó cũng sẽ tạo ra những thay đổi (và có lẽ đối với cùng một thư mục, dù hi vọng là sẽ không cùng file). Vì vậy nên chúng ta cần phải tạo ra hai bản SD cùng một lúc - một dành cho Windows Update, một dành cho những thứ khác. Có lẽ sẽ ảnh hưởng tới khả năng hoạt động đấy, nhưng chúng ta có thể làm được việc đó.<br> <br>Giờ cứ cho rằng Windows Update đã update xong đi, và nói với Windows đóng những SD của nó lại — hay nói cách khác, ghi tất cả những thay đổi vào phiên bản “thông thường” của hệ thống, và cho những chương trình còn lại nhìn thấy. Và giờ mọi thứ sẽ loạn hết lên đây. Vì những chương trình đó đang có một vài file DLL của Windows load vào bộ nhớ, và những bản copy đang ở trong bộ nhớ ấy là phiên bản cũ nhé. Và nếu những chương trình đó mở những thành phần của Windows mà chúng chưa sử dụng trước đây - hoặc ngay cả khi chúng sử dụng những tính năng chưa từng được dùng trước đó - thì có thể cũng sẽ trộn những thành phần cũ và mới của Windows lại với nhau trong bộ nhớ trong cùng thời điểm. Và có lẽ chúng chẳng biết gì về cái cách mà mọi thứ đang nằm trong bộ nhớ và cái cách mà những phần khác của hệ thống đang liên hệ với nhau (sau cùng thì, tạo ra thay đổi cho những phần đó là một trong những lí do chính để tạo ra những update). Và các chương trình bắt đầu tắt ngấm (crash) và sẽ mất dữ liệu và người dùng rõ ràng chẳng vui vẻ gì.<br>Liệu chúng ta có thể nói rằng “được rồi, những chương trình đang chạy trước đó đều sử dụng phiên bản cũ của Windows và những chương trình mới chạy thì dùng phiên bản mới hay không? Có đấy. Khá khó làm và sẽ ảnh hưởng tới hiệu suất nhiều hơn, nhưng tôi tin rằng những gã thông minh tạo ra các bản SD những ngày đầu có thể làm được việc đó. Nhưng trong Windows mới thì, các chương trình luôn luôn tương tác với nhau. Bạn sẽ phải vật lộn giữa những mớ hỗn độn khi chương trình Windows cũ nói chuyện với chương trình Windows mới, và nói chuyện với những phần cũ hoặc mới của Windows của được chương trình cụ thể nào đó sử dụng, và vv. Và sẽ ra sao nếu những phiên bản cũ và mới của Windows có thông tin khác nhau về cách phân chia một tài nguyên chung, ví dụ, registry chẳng hạn?<br> <br>Và từ đó tôi đi tới kết luận của mình. Mọi thứ tôi nhắc đến là những vấn đề kỹ thuật. Và những vấn đề kỹ thuật đó có thể được loại bỏ nếu bạn dành đủ nguồn lực cho chúng. Tôi tin rằng ta có thể làm được chuyện đó. Nhưng hãy dừng lại một chút và xem xét chuyện này: Chúng tôi, những con người ở Microsoft, đã nhận được rất nhiều lời chỉ trích mạnh mẽ về vấn đề chất lượng. Chúng tôi cần phải cải thiện. Chúng tôi cần kiểm tra mọi thứ tốt hơn. Còn cần phải tạo ra những sản phẩm một cách cẩn thận hơn. Nhưng hiện tại thì, hãy tưởng tượng rằng nếu chúng tôi nói rằng “Trước khi tung ta một bản update mới thì, chưa thể kiểm tra xem nếu phiên bản Windows mới đó có hoạt động tốt như mong đợi trong mọi tình huống được đâu. Bạn còn cần phải kiểm tra mọi tổ hợp có thể có từ những thành phần mới / được cập nhật của Windows với mọi tổ hợp có thể của những thành phần Windows cũ hiện có, bao gồm cả trường hợp mà những chương trình khác nhau có thể cùng lúc chạy những phiên bản khác nhau của cùng một thành phần”. Tôi không nghĩ rằng mình có thể diễn đạt được chuyện đó phức tạp đến mức nào. Và nếu hiện tại chúng tôi không đủ khả năng kiểm thử đồ của mình một cách hiệu quả với mô hình hiện tại, thì chẳng có lí do gì để chúng tôi lại đi thử một thứ còn phức tạp hơn thế cả.<br> <br>Giờ bạn sẽ thấy rằng tại sao Windows lại cần restart sau khi kết thúc cài đặt update. Dù chúng tôi có ghi những thay đổi vào đĩa một cách thông minh tới đâu đi chăng nữa trong lúc thực hiện update thì, hiện tại cách duy nhất để đảm bảo cho các chương trình đều hoạt động nhất quán - và cũng là cách duy nhất tránh được thảm họa kiểm thử tôi đề cập đến ở trên - ấy là nói rằng “Được ròi, chúng tôi đã có các file update rồi đây, chúng tôi sẽ nhẹ nhàng tắt phiên bản cũ đi và cũng sẽ rất từ tốn bật phiên bản mới lên”.<br> <br>Tôi biết câu nói ấy không làm cho việc restart bớt khó chịu lẫn đau đớn đi đâu, và một lần nữa tôi xin lỗi vì chuyện đó, nhưng giờ đây, ít nhất tôi hi vọng bạn hiểu hơn rằng tại sao chuyện đó lại xảy ra.<br> <br>EDIT: Nhiều người tử tế đã hỏi những câu kiểu như “Tại sao những hđh khác thường không gặp chuyện này”, vì vậy hãy để tôi giải thích nhé:<br> <br>Nhiều hđh khác CÓ gặp phải chuyện đó đấy, macOS, iOS và Android sẽ thường yêu cầu khởi động lại (reboot) sau những update quan trọng.<br> <br>Linux là một ngoại lệ lớn, nó thường có thể update bất kỳ thứ gì mà không cần reboot ngoại trừ nhân (kernel), và một vài bản còn có thể cài đặt update nhân mà không cần reboot. Linux có nguồn gốc từ Unix, và Unix được thiết kế như một hđh cho nhiều người dùng ngay từ lúc đầu, không như phần lớn hđh cho PC khác (chỉ bắt đầu là hđh một người dùng và rồi sau đó có thêm tính năng nhiều người dùng sau đó), và cũng chẳng giống những hđh dành cho điện thoại (thường chủ yếu là một người dùng). Phần lớn vì nhu cầu hỗ trợ cùng lúc nhiều người dùng đó nên Unix (và Linux) mới được thiết kế với nhiều lớp bảo mật, tách biệt và trừu tượng tách bạch các chương trình, tách các chương trình khỏi hđh, và tách bạch các thành phần của hđh. Các tiếp cận nhiều lớp này đã gây ra những hình phạt về hiệu suất khá đáng kể; nhưng vì hệ thống rất cần điều này để có thể sử dụng được, nên những nhà thiết kế Unix (và Linux) đã muốn và có thể chịu được những hình phạt đó để có được lợi ích về bảo mật và bảo trì. Theo cách thiết kế đó, gần như bất kỳ thành phần nào của Unix (hay Linux) có thể được update mà không cần reboot. Và giờ đây những CPU còn có nhiều khả năng hơn trước, phần lớn PC không sử dụng hết được sức mạnh của nó thì, quyết định này thực sự sáng suốt - hình phạt về hiệu suất không còn quan trọng nữa, và Linux có ưu thế lớn về điểm này.<br> <br>(Và bên cạnh đó, đây cũng là ví dụ cho thấy khả năng của một hđh đã đề cao những khả năng của nhà phát triển. Lõi của macOS là Unix, nên về lý thuyết, nó cũng có được lợi thế này. Nhưng phiên bản đầu của macOS đã được tạo ra cách đây hai mươi năm rồi. Những lớp tách biệt và trừu tượng cho phép update mà không cần reboot là cái giá mà lập trình viên không chỉ phải trả có một lần thôi đâu; nó yêu cầu họ phải làm việc nhiều trong khoảng thời gian liên tục, viết code và kiểm thử khi hđh đó phát triển. Và trong khi macOS vẫn có khả năng hỗ trợ đa người dùng, thì phần lớn hđh macOS chỉ có một người dùng vào một thời điểm mà thôi, và Apple hiểu điều đó. Họ đã định hướng sự phát triển sản phẩm của mình theo hướng đa dạng kịch bản một người dùng, thay vì duy trì những phần tách biệt và kiểm thử mọi tổ hợp của các thành phần có thể có. Có lẽ nên theo đó, phần lớn những update của macOS - update cho hđh hơn là cho ứng dụng - yêu cầu bạn phải reboot).<br> <br>Tôi sẽ rất thích thú khi được đưa những phần tách biệt và trừu tượng ấy vào Windows. Nhưng vì những lí do kỹ thuật, sẽ cực kỳ khó để có thể làm việc đó mà không phá vỡ tính tương thích với những phần mềm hiện có - và “tính tương thích với các phần mềm hiện có” là lý do quan trọng nhất khiến người ta dùng Windows ngay từ đầu. Đó có lẽ là lý do khiến phần lớn những nỗ lực của chúng tôi chỉ là để khiến việc reboot đỡ đau đớn mà thôi, bằng cách khiến những lần reboot ấy nhanh chóng hơn, duy trì trạng thái hiện tại của người dùng tốt hơn, hơn là tập trung vào việc loại bỏ reboot.<br> <br>EDIT: Wow! Khá nhiều uovote đó chứ nhỉ. XIN CẢM ƠN CÁC BẠN! Tôi rất vui vì thông tin này là hữu ích.<br> <br>https://www.quora.com/Why-does-Windows-require-a-restart-after-installing-updates-If-I-understand-correctly-this-could-be-avoided-if-the-Windows-development-team-made-clever-use-of-their-own-shadow-copy-technologies/answer/Mark-Phaedrus<br><br><img src='https://scontent.fhan17-1.fna.fbcdn.net/v/t1.6435-9/50592012_2284029665176922_5081857406875467776_n.jpg?_nc_cat=106&ccb=1-7&_nc_sid=ca434c&_nc_ohc=f2o_iDz9GswAX-Aavkm&_nc_ht=scontent.fhan17-1.fna&edm=AFuVL-cEAAAA&oh=00_AfDoNtOILOwUHQNdHGsNNmOgSiaQM2gWNR1-9ZhWosLJDw&oe=63D0BCB1'></div>