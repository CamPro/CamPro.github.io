<div>622<br><br>#computerScience #coding #vmc<br><br>Q: Nếu một máy tính thực hiện được một triệu phép tính mỗi giây thì tại sao đoạn code **for (int I = 0; I < 1000000; I++) {cout <<I;} **lại chạy mãi chẳng xong vậy?<br><br>A: Steve Baker, Blogger LetsRunWithIt.com (2013-nay)<br><br>L: 1100 word<br><br>[[LINK]](https://www.quora.com/If-a-computer-does-a-million-processes-per-second-how-come-for-int-I-0-I-1000000-I-cout-I-takes-forever/answer/Steve-Baker-100) <br><br>============<br>(Ví dụ) nếu bạn viết đoạn code NÀY bằng ngôn ngữ C hoặc C++ nhé:<br><br>**for ( int i = 0 ; i < 1000000 ; i++ ) x += i ;**<br><br>(Hãy lưu ý rằng tôi đã thay đổi đoạn mã để cộng tổng tất cả các số từ 0 tới 1000000 thay vì hiển thị các con số đó lên màn hình - RẤT quan trọng đấy!)<br><br>…và dịch đoạn đó thành mã máy thì máy tính sẽ phải:<br><br>- Kiểm tra xem liệu ‘i’ có còn nhỏ hơn 1 triệu nữa không.<br><br>- Cộng ‘i’ vào ‘x’<br><br>- Tăng ‘i’ lên một<br><br>- Quay ngược lại đoạn ban đầu và làm lại hết tất cả<br> <br> <br><br>Có khoảng 4 đoạn lệnh mã máy - mỗi đoạn được thực thi một triệu lần - khoảng 4 triệu lệnh. Và do máy tính của bạn có thể thực hiện hàng TỶ lệnh mỗi giây nên đoạn code này có thể chạy rất nhanh... Chậc, còn dưới một một phần ngàn giây đối với những chiếc máy tính hiện đại nữa kia.<br><br>Giờ thì... Tất cả những điều tôi đang nói đều được đặt ra với giả thiết rằng bạn đang dùng C hoặc C++ và dịch chương trình đó ra mã máy nhé.<br><br>** **<br><br>**Nhưng câu hỏi bạn đặt ra ấy là:**<br><br>**for ( int i = 0 ; i < 1000000 ; i++ ) cout << i ;**<br><br> <br><br>Mới nhìn qua thì đối với máy tính, đoạn “cout << i;” không khác lắm so với “x += i ;” - nhưng lại ‘khoai’ thật đấy!<br><br>Cứ thử nhìn xem máy tính sẽ phải làm gì để thực hiện một vòng lặp của đoạn mã ĐÓ nhé:<br><br>- Kiểm tra xem liệu ‘i’ có còn nhỏ hơn 1 triệu nữa không.<br><br>- Tăng ‘i’ lên một<br><br>- Gửi ‘i’ tới bộ đầu ra chuẩn. Và điều đó đồng nghĩa với việc:<br><br>o Việc chuyển đổi số ‘i’ đó thành một xâu theo chuẩn ký tự ASCII cơ số 10 và thêm cả một ký tự rỗng (null terminator)… đòi hỏi một hàm khá phức tạp, kiểm tra xem số đó có âm hay không (trường hợp này thì là không) và rồi lại phải thực hiện một vòng lặp làm vài thứ kiểu chia liên tiếp ‘i’ cho 10 và cộng mã ASCII của ‘0’ vào mỗi chữ số. Có lẽ điều này tương đương với khoảng một vài trăm phép xử lý máy tính - số càng lớn càng phải thực hiện nhiều lần hơn.<br><br>o Gửi xâu chứa các chữ số đó tới “standard output” stream - giờ lại cần thêm một vài vòng lặp để sao chép mỗi ký tự ASCII đó vào một bộ đệm (buffer) trong object cout stream. Thêm vài chục câu lệnh nữa nhé.<br><br>o Kiểm tra xem bộ đệm đó đã đầy chưa - chắc cứ vài trăm vòng lặp là phải làm một lần và nếu đầy thì sao...<br><br>o Gửi bộ đệm đó tới hệ thống phân chia cửa sổ…lại HÀNG TRĂM câu lệnh nữa.<br><br>o Hệ thống phân chia cửa sổ sẽ xác nhận xem bộ đệm đó sẽ được gửi tới cửa sổ hiện hành nào.<br><br>o Tìm xem loại font đang được sử dụng là gì.<br><br>o Kiểm tra xem xâu đó có chứa những ký tự như tab, dấu backspace hay newline hay không - hoặc xem nó có in đậm, nghiêng gì không.<br><br>o Có thể nó sẽ cho rằng cửa sổ cần được cuộn lên và sẽ phải update lại thanh cuộn và chuyển mọi thứ khác lên trên. Vì bạn có thể tự mình dùng chuột cuộn cửa sổ đó lên nên máy cũng phải lưu lại những ký tự đó ở nơi nào đó để bạn có thể cuộn xem lại về sau. (Hàng triệu câu lệnh luôn!)<br><br>o Sau đó nó phải gọi tới driver đồ họa để sử dụng card đồ họa.<br><br>o Từ đó máy phải gọi kernel hệ điều hành, và kernel đấy phải lưu lại trạng thái chương trình để sau có thể sử dụng lại (hàng trăm câu lệnh nhé)...<br><br>o Việc này đồng nghĩa với việc nó phải kiểm tra xem có chương trình nào khác cần chạy hay không. - và có thể phải chạy những chương trình đó một lúc đấy (hàng chục triệu câu lệnh nữa!).<br><br>o Cuối cùng là câu lệnh vẽ các điểm ảnh tạo nên ký hiệu cho giá trị thập phân của ‘i’ và được gửi vào hàng chờ để gửi tới chip GPU (lại vài trăm câu lệnh nữa nhé).<br><br>o Khi GPU xong việc (có thể tốn thời gian một chút nếu có chương trình nào khác muốn hiển thị cái gì đó) - thì dữ liệu để cập nhật lại cửa sổ của bạn sẽ được gửi tới GPU thông qua cơ chế “DMA” (direct memory acess) khi có thời gian.<br><br>o Thoát tất cả những câu lệnh đó và chờ hệ điều hành quyết định xem lúc nào có thể chạy chương trình đó một lần nữa...<br><br>o Và CUỐI CÙNG...<br><br>· Quay ngược lại đoạn ban đầu và làm lại hết tất cả những thứ trên đây.<br> <br><br>Vì thế vấn đề là -  ***chính vòng lặp*** đó chỉ tốn khoảng một phần tỷ giây mỗi lần lặp thôi - song những gì bạn làm ***trong vòng lặp đó*** là thứ gây nên một loạt phản ứng dây chuyền, những thứ ***thực sự*** phức tạp đó!<br><br>Một trong những bài học mà bạn phải học được khi lập trình ấy là Input/Output là thứ ngốn tài nguyên nhất mà một chương trình có thể thực hiện.<br><br>Đây không phải là khả năng duy nhất có thể xảy ra đâu - bạn có thể sẽ phải điều hướng standard output stream tới một file nào đó trên đĩa cứng... Từ đó dẫn tới việc điều hướng một mớ hổ lốn các process và driver khác nữa.<br><br>Thực tế thì, đối với những thứ như video game - toàn bộ process phải được rút ngắn bất cứ khi nào có thể bằng việc để chương trình kết nối trực tiếp với chip graphic - loại trừ tất cả những bước trung gian và chỉ để lại một vài thao tác nhỏ vậy thôi.<br><br>Máy tính nhanh vãi lúa - song chúng cũng phải thực hiện những công việc điên khùng vãi lúa luôn đấy!!<br><br><img src='https://scontent.fhan17-1.fna.fbcdn.net/v/t1.6435-9/60856493_2355999274646627_1609971901109633024_n.jpg?_nc_cat=111&ccb=1-7&_nc_sid=ca434c&_nc_ohc=H1t5KdwjCSsAX8ZMIXm&_nc_ht=scontent.fhan17-1.fna&edm=AFuVL-cEAAAA&oh=00_AfAxwxrhsQSGBjPnjG8tuKeeclg8WXtcAVK0Md0jxaV0gQ&oe=63D0BD71'></div>