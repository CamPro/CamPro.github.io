<div>Nếu các tập tin thực thi là các chương trình được chuyển đổi sang mã máy, tại sao chúng không thể chạy được trên bất kỳ hệ điều hành nào? Không phải mã máy là thứ hoạt động trực tiếp với bộ xử lý sao?<br><br>---------<br><br>Steve Baker, Blogger ở LetsRunWithIt.com (2013 - hiện tại)<br><br>---------<br>Trên lý thuyết - bạn đúng - nhưng vấn đề là một "chương trình" không thực sự tự bản thân nó làm mọi việc. Khi chương trình của bạn làm một thứ như thế này chẳng hạn :<br><br>```<br>printf ( “Hello World\n” ) ;<br>```<br><br>...điều xảy ra ở đây là trình biên dịch tạo ra các đoạn mã để gọi hàm "printf" từ thư viện - nhưng bản thân hàm đó cũng phải gọi một hàm khác từ hệ điều hành để thực sự làm mọi thứ hiện lên màn hình.<br><br>Vì nhiều chương trình có thể chạy cùng lúc - và dòng chữ của bạn cuối cùng sẽ nằm trong một cửa số, điều đó có nghĩa là bạn sẽ gửi một yêu cầu tới phần quản lý cửa sổ và kế đó là trình điều khiển thiết bị.<br><br>Tất cả những thứ đó vẫn chỉ là mã máy - nhưng chúng chạy bên trong hệ điều hành.<br><br>Bởi vì những tác giả của các hệ điều hành khác nhau chọn những cách khác nhau để làm điều đó, hàm `printf` sẽ phải chứa những đoạn mã không hề giống nhau cho mỗi OS - và vì `printf` cũng là một hàm thư viện mà cuối cùng sẽ được liên kết với chương trình của bạn, nó sẽ trở nên khác biệt đối với mỗi nền tảng.<br><br>Vì thế, đoạn mã thực sự của `printf` trên Mac, Windows và Linux khác nhau HOÀN TOÀN.<br><br>Tệ hơn nữa, không phải mọi máy tính đều có CPU giống nhau. Tất nhiên là hầu hết máy tính đều có CPU từ Intel hoặc những hãng khác với khả năng tương thích đi kèm, nhưng những chiếc điện thoại, tablet và một vài mẫu Chromebook thì chứa bộ xử lý ARM bên trong - với một loại mã máy hoàn toàn khác : giá trị biểu diễn cho lệnh ADD, các chế độ đánh địa chỉ và các thanh ghi không hề giống nhau.<br><br>Mặt khác, hệ điều hành phải tải tập tin nhị phân với mã máy của bạn vào RAM và thực thi nó - và định dạng mà mỗi OS dùng cho việc lưu trữ chúng là khác nhau : định dạng ".exe" (ý ông là PE32+? - người dịch) của Windows là một thứ không hề giống với ELF trên Linux.<br><br>Vì thế, trên lý thuyết, bạn đúng khi và chỉ khi những người viết hệ điều hành và các nhà sản xuất CPU trên khắp thế giới này có thể cùng thỏa thuận về việc dùng chung một tập các giao diện, cùng một tập lệnh và cùng một định dạng tập tin.<br><br>Nhưng - dĩ nhiên rồi - họ không làm thế, và ở một mức độ nào đó, điều đó là không thể.<br><br>Nếu mọi người bị buộc phải dùng chung một thứ, sẽ rất khó để thực hiện sự đổi mới. Đó là một phần quan trọng trong ngành điện toán - mọi thứ thay đổi liên tục.<br><br>Một chương trình viết cho Windows 10 có thể sẽ không chạy trên Windows 7 - và một tập tin thực thi được biên dịch cho Linux x64 sẽ không hoạt động được trên một hệ thống x86...chúng ta thì không muốn điều đó xảy ra, vì nếu vậy, sẽ không còn có thể thêm các tính năng mới.<br><br>Vì thế, buồn thay, chúng ta (ít nhất) vẫn phải biên dịch lại các chương trình để có thể thực thi được đối với mỗi kết hợp OS và CPU.<br><br>Ở điều kiện lý tưởng thì mã nguồn của chúng ta sẽ giống nhau trên bất kỳ nền tảng nào - nhưng, dĩ nhiên rồi, đời không như là mơ. Hầu hết các chương trình lớn chạy được trên nhiều hệ điều hành đều chứa mấy thứ kiểu như thế này :<br><br>```<br>#ifdef LINUX<br>...làm cái này...<br>#elif WINDOWS<br>...thực hiện cái kia...<br>#elif MAC<br>...làm một điều gì đó khác...<br>#else<br>...báo lỗi - nền tảng không được hỗ trợ...<br>#endif<br>```<br><br>Tất nhiên, có những cách để vượt qua trở ngại đó.<br><br>Tiêu chuẩn WebAssembly mới cho các chương trình được biên dịch để hoạt động trong các trình duyệt xử lý tất cả các vấn đề trên...với một cái giá phải trả :<br><br>Các tập tin WebAssembly không thực sự chứa "mã máy" - chúng chứa mã thực thi cho một máy tính giả tưởng gần-gần-giống máy thật. Khi trình duyệt tải một chương trình vào bộ nhớ, nó dịch các chỉ lệnh đó sang các lệnh tương ứng cho hệ thống mà bản thân trình duyệt đang thực sự chạy trên đó. Quá trình ánh xạ này không phải là chính xác, và có sự suy giảm hiệu năng ở đây - một chương trình C++ biên dịch với WebAssembly chỉ chạy với tốc độ ~85% so với khi biên dịch trên một nền tảng x86.<br><br>Một chương trình WebAssembly KHÔNG BAO GIỜ được giao tiếp trực tiếp với hệ điều hành - thực chất thì điều đó bị cấm - và có nhiều phương thức đã được tạo ra để ngăn chặn điều đó. Thay vào đó, các hàm JavaScript được gọi, từ đó góp phần tạo ra một giao diện chung; các nhà phát triển của những trình duyệt Web đã làm điều mà chưa một tác giả của bất kỳ OS nào khác đã làm : lập một ủy ban chuyên trách cho việc tiêu chuẩn hóa. Họ cũng có một thứ - kiểu như thỏa thuận ấy - rằng các chức năng cốt lõi sẽ luôn luôn được thiết kế giống nhau. Dĩ nhiên là điều này giới hạn khả năng sáng tạo đi khá nhiều.<br><br>Bảo mật là điều được quan tâm nhất trong WebAssembly - vì thế, nó an toàn ở mọi khía cạnh. Ý tôi không phải là việc viết các phần mềm độc hại sẽ trở nên bất khả thi - nhưng đó là điều mà đặc tả của WebAssembly đã nói tới. Điều này chưa bao giờ là đúng với các chương trình chạy trực tiếp trên máy tính.<br><br>Đương nhiên, nếu bạn đã chuẩn bị để chấp nhận những giới hạn này, đây là sẽ là cách để bạn thực sự có thể có những đoạn mã "viết một lần - chạy mọi nơi".<br><br>---------<br>Translated from http://qr.ae/TUhpfs<br>with Atom IDE in 1:00:02<br><br>---------<br>Vui lòng không bê bài đi nơi khác trước khi được tác giả đồng ý =))<br>P/s : chúng ta có nên làm một trang dịch bài như Reddit Việt Nam?<br><br><img src='https://external.fhan17-1.fna.fbcdn.net/emg1/v/t13/15363256679590356669?url=https%3a%2f%2fqph.fs.quoracdn.net%2fmain-custom-t-980-600x315-sqxxospfciejqkjfytssmfbdcvzbbxla.jpeg&fb_obo=1&utld=quoracdn.net&stp=dst-emg0_q75&ccb=13-1&oh=06_AbGE4kqiJMnw9HWzVruuPqBF9WnYIcGPQygT6nu4jqtvaA&oe=63AB1CDF&_nc_sid=5f3a21'></div>