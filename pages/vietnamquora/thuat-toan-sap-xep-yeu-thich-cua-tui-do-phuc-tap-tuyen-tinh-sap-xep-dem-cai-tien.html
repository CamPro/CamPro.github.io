<div># **Thuật toán sắp xếp yêu thích của tui (độ phức tạp tuyến tính) – Sắp xếp đếm cải tiến**<br><br>#medium #algorithm #sort #code<br><br>[Tác giả: Franziska Hinkelmann<br><br> Ngày xuất bản: 31/01/2019<br><br> Link bài viết gốc: https://link.medium.com/OeAGc2Rd43 <br><br> Dịch: Bùi Thanh Lâm]<br>> **Bài toán: Cho một mảng các số chưa sắp xếp. Tìm khoảng cách lớn nhất giữa hai phần từ liên tiếp sau khi mảng đã được sắp xếp. Số đã cho có thể là số âm, số thập phân.**<br><br>*Ví dụ: Cho mảng [21, 41, 17, 45, 9, 28], khoảng cách lớn nhất cần tìm là 13 (41 và 28).*<br>## Thuật toán tiếp cận trực tiếp<br><br>***Code (JavaScript) **(ND: [Click](https://pastebin.com/JQ8d68WN) để xem)*<br><br>Trước hết, ta sắp xếp mảng. Trong ví dụ trên, ta thu được kết quả là: [9, 17, 21, 28, 41, 45].<br><br>Tiếp đó, cứ đến mỗi cặp phần tử, tính khoảng cách giữa chúng; nếu nó lớn hơn khoảng cách lớn nhất hiện tại, ta cập nhật giá trị mới cho khoảng cách lớn nhất (ND: biến acc trong code).<br><br>Cụ thể:<br>* max(0, 0) = 0<br>* max(0, 8) = 8<br>* max(8, 4) = 8<br>* max(8, 7) = 8<br>* max(8, 13) = 13<br>* max(13, 4) = 13<br><br>Độ phức tạp thuật toán trường hợp này là O(n.logn) cho việc sắp xếp, và O(n) cho tìm khoảng cách lớn nhất. Vậy tổng hợp lại, đó là O(n.logn).<br><br>Có một định lý rằng “mọi thuật toán sắp xếp sử dụng so sánh đều có độ lớn tạp không nhỏ hơn O(n.logn)” (ND: định lý này đã được chứng minh). Do đó chúng ta không thể tìm được phương án nào chạy nhanh hơn nếu vẫn sử dụng sắp xếp có so sánh.<br><br>Khá thú vị rằng, vẫn tồn tại thuật toán chạy với độ phức tạp tuyến tính cho bài toán này đó. Hãy cùng tìm hiểu về nó nào!<br>## Thuật toán với độ phức tạp tuyến tính<br><br>Các thuật toán sắp xếp sử dụng so sánh như sắp xếp trộn (merge sort), sắp xếp vun đống (heap sort), hay sắp xếp nhanh (quick sort) đều vượt quá độ phức tạp tuyến tính mà chúng ta đang cần. Vậy sắp xếp đếm (counting sort) thì sao?<br><br>Counting sort là một thuật toán sắp xếp các số nguyên có độ phức tạp thời gian là O(n+w) nhưng lại cần một không gian w, trong đó w là giá trị của phần tử lớn nhất trong mảng đã cho. Thuật toán chạy tốt nếu các số nguyên đã cho đủ nhỏ. Thuật toán sử dụng một mảng phụ được gọi là mảng đếm hay mảng tần số.<br><br>**Thuật toán sắp xếp đếm**<br>* Với mỗi phần tử i, tăng một đơn vị vào ô nhớ thứ i trong mảng đếm.<br>* Duyệt từ đầu đến cuối mảng đếm. Ở mỗi ô nhớ có giá trị lớn hơn 0 trong mảng đếm, thêm vị trí ô nhớ ấy vào mảng kết quả.<br><br>(ND: cơ chế của thuật toán này tương đối giống bảng băm – hash table)<br><br>Xây dựng mảng đếm tốn O(n), duyệt hết mảng đếm và thêm vào mảng kết quả tốn thêm O(w) nữa. Vậy tổng cộng tốn O(n+w) về thời gian chạy.<br><br>Tuy nhiên, sắp xếp đếm thuần tuý không dùng được trong bài toán chúng ta đang xét lần này bởi những lý do sau:<br><br>1. Các số đã cho có thể chứa số âm<br><br>2. Các số đã cho có thể là số thập phân<br><br>3. Các số đã cho có thể lớn<br><br>Tuy nhiên nếu quan sát tinh tế hơn, ta có thể cải tiến sắp xếp đếm để có được một thuật toán với độ phức tạp tuyến tính cả về thời gian chạy và không gian bộ nhớ. <br><br>**Thuật toán sắp xếp đếm cải tiến**<br><br>Gọi max, min lần lượt là phần tử lớn nhất và nhỏ nhất trong các số đã cho. Khoảng cách lớn nhất cần tìm phải lớn hơn hoặc bằng đại lượng: lowerBound = (max-min)/(n-1).<br><br>Thật vậy. Trong ví dụ trên, n = 6, min = 9, max = 45, lowerBound = 36/5 = 7.2. Nếu 4 phần tử còn lại phân bố đều giữa 9 và 45, thì khoảng cách lớn nhất cần tìm đúng bằng 7.2.<br><br>Do đó, bất kể 4 số còn lại phân bố như thế nào, chắc chắn tồn tại 2 số liên tiếp (sau khi sắp xếp) mà khoảng cách của chúng lớn hơn hoặc bằng 7.2.<br><br>Nhờ quan sát được điều này, ta sẽ chia miền giá trị đầu vào thành n-1 đoạn, mỗi đoạn dài một lượng là lowerBound. Hai số xa nhất sẽ không thể nằm vừa một đoạn.<br><br>Ta sẽ gom mỗi phần tử i vào một đoạn. Sắp xếp phân đoạn chạy rất tồi nếu các số nằm sát nhau, bởi các số nằm cùng một đoạn sau đó sẽ phải được sắp xếp bằng so sánh. Ta sẽ khắc phục vấn đề này bằng việc chỉ quan tâm tới phần tử lớn nhất và nhỏ nhất trong mỗi đoạn mà thôi.<br><br>Sở dĩ chúng ta có thể bỏ qua các phần tử ở giữa mỗi đoạn bởi đã có đại lượng lowerBound vừa là cận trên của khoảng cách giữa 2 số liên tiếp thuộc cùng một đoạn, vừa là cận dưới của khoảng cách lớn nhất cần tìm.<br><br>Chúng ta sẽ tìm khoảng cách lớn nhất bằng cách duyệt lần lượt n-1 đoạn, mỗi đoạn có nhiều nhất 2 số (ND: tức max và min của mỗi đoạn trong trường hợp đoạn đó có nhiều hơn 1 số thuộc về. Trường hợp đoạn chỉ chứa một số, gán: max = min = số đó. Trường hợp đoạn không có số nào thuộc về, ta bỏ qua. Ta sẽ tính hiệu của min đoạn sau và max đoạn trước, cập nhật giá trị lớn hơn vào biến kết quả, cứ thế duyệt đến hết các đoạn, ta thu được khoảng cách lớn nhất cần tìm. Đoạn này quan trọng, mình không hiểu sao OP viết khá sơ sài).<br><br>***Code (JavaScript) **(ND: [Click](https://pastebin.com/ieSEBYBT) để xem)*<br><br>Thuật toán này chạy trong thời gian tuyến tính, không phụ thuộc vào biên độ đầu vào, và chỉ cần một bộ nhớ phụ cũng tuyến tính.<br>## Hiệu suất<br><br>O(n) hẳn là phải nhanh hơn O(n.logn) nếu đầu vào đủ lớn. Trong thực tế thì sao?<br><br>Với đầu vào nhỏ hơn 10,000 phần tử, phương pháp tiếp cận trực tiếp dùng hàm array.prototype.sort() chạy nhanh hơn thuật toán độ phức tạp tuyến tính. Với lượng đầu vào lớn, thuật toán độ phức tạp tuyến tính này sẽ nhanh hơn: chẳng hạn nếu cho 10,000,000 phần tử, thời gian chạy sẽ là 4 giây, thay vì 15 giây.<br><br>• Mảng 1,000 phần tử:<br><br>n log(n): 0s<br><br>Tuyến tính: 0.001s<br><br>• Mảng 10,000 phần tử:<br><br>n log(n): 0.012s<br><br>Tuyến tính: 0.01s<br><br>• Mảng 5,000,000 phần tử:<br><br>n log(n): 5.914s<br><br>Tuyến tính: 1.793s<br><br>• Mảng 10,000,000 phần tử:<br><br>n log(n): 15.611s<br><br>Tuyến tính: 3.896s<br>## Tổng kết<br><br>Sắp xếp đếm thuần tuý là một thuật toán sắp xếp số nguyên chạy với thời gian O(n). Mọi giải thuật sắp xếp sử dụng so sánh khác tốn tối thiểu O(n.logn).<br><br>Bởi tồn tại một cận dưới cho khoảng cách lớn nhất cần tìm, do đó ta có thể dùng một thuật toán có độ phức tạp tuyến tính, một biến thể của sắp xếp đếm và sắp xếp phân đoạn.<br><br>Toàn bộ mã nguồn được đẩy lên [Github](https://github.com/fhinkel/twitch/blob/master/max-gap.js). Tôi cũng có một [video](https://youtu.be/oZyomw_N70o) trên Youtube livestream và code về lời giải này.<br><br>----<br><br>*Chú thích của người dịch:*<br>1. *Bài dịch hướng đến các bạn có hứng thú về thuật toán, lập trình. Các bạn không quan tâm tới chủ đề này cũng vẫn được chào đón bình thường, nhưng không khuyến khích bình luận ngoài chủ đề.*<br>1. *Mã nguồn được tác giả viết bằng ngôn ngữ JavaScript (JS). Nếu chưa biết ngôn ngữ này, bạn đọc nên tự tìm hiểu thêm về cú pháp các hàm được sử dụng trong bài.*<br>1. *Trong bài viết gốc sử dụng từ “bucket” (nghĩa là chậu nước). Để trực quan, mình sẽ dịch là “đoạn”, và vì thế “bucket sort” dịch là “sắp xếp phân đoạn”.*<br>1. *Theo mình, tác giả có nhầm lẫn rằng chỉ có n-1 đoạn. Mình cho rằng, theo như code thì sẽ có n đoạn, thêm đoạn cuối cùng đặc biệt, chỉ có duy nhất phần tử max. Tuy nhiên, thuật toán vẫn chạy O(n), code hoàn toàn đúng, và điều này không ảnh hưởng đến tổng thể. Nhìn chung, đây là một bài viết thú vị và là một bài dịch tâm đắc của mình.*<br><br><img src='https://scontent.fhan17-1.fna.fbcdn.net/v/t1.6435-9/86807729_1474417226051557_927142882106671104_n.jpg?stp=dst-jpg_s720x720&_nc_cat=106&ccb=1-7&_nc_sid=ca434c&_nc_ohc=WeUwcRTTn-QAX_j2kLN&_nc_ht=scontent.fhan17-1.fna&edm=AFuVL-cEAAAA&oh=00_AfBdXXE3-yXV74YQJD-W6JIfDqwylLKLixsV4bB9TMxhLQ&oe=63D0C582'></div>