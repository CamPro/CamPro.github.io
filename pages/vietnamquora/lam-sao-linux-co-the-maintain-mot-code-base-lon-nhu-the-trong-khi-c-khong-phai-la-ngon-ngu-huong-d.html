<div>**Làm sao Linux có thể maintain một code base lớn như thế trong khi C không phải là ngôn ngữ hướng đối tượng (OO)? Code base có rối tung hết lên không?**<br><br>Link Quora: https://qr.ae/TzPapO<br><br>**Trả lời: William Westlake, Software and Information Systems SME tại Unified Business Technologiess (2014-present)**<br><br>Đầu tiên thì, không, source code (mã nguồn) của Linux cơ bản là code sạch nhất đấy, không tin tôi ư? Hãy vào trang Github của linux: github.com/torvalds/linux và tự mình xem thử.<br><br>Đầu tiên, OO (Object-oriented) không phải một phép màu có thể giúp bạn viết ra code xịn hơn. OO được xây dựng để và nên được dùng để mô hình hóa một số loại hệ thống nhất định mà sẽ phức tạp hơn khi mô hình hóa bằng các mô hình lập trình khác mà thôi. OO có thể, và thường được viết một cách tệ hại, tôi đã thấy điều này quá thường xuyên rồi.<br><br>Tôi thường bảo các coder khác nên suy nghĩ trước khi họ tạo một class mới. Nếu thứ họ muốn làm có thể thực hiện bằng cách sử dụng phương thức static hoặc stateless(1), thì họ nên làm theo cách đó. Một người reivew code của tôi đã từng nhìn vào một đoạn code của tôi và nói, wow, tất cả đều là phương thức static, điều này thật tuyệt, dễ để dõi theo. Cô ấy đã thực sự bất ngờ rằng static code lại dễ hiểu hơn OO code. Tui nói nói và giải thích cho cô ấy, giờ thì cô ấy trở thành fan của static code luôn rồi.<br><br>Và cuối cùng, trong một OS (hệ điều hành), code của bạn đang chạy kiểu mò mẫm? (flying by the seat of its pants). Kernel code (code của hạt nhân hệ điều hành) thường bị giới hạn nhiều thứ, các biến và các thứ tương tự phải được cấp phát tĩnh (static allocated). Nhiều phần của hệ điều hành cần phải truy cập bằng các ký hiệu, vậy nên chẳng thể dùng name mangling (2). Cấp phát động (dynamic allocation) ư? Bạn không thể viết trình quản lý bộ nhớ mà dùng cấp phát động được, nó chưa có ở đó, trình quản lý bộ nhớ chính là thứ dùng để cấp phát động. Virtual methods (hàm ảo)? Quá nhiều thứ gián tiếp, hệ điều hành cần làm công việc của nó và lượn đi ngay. Khi một hệ điều hành khởi động, nó hoàn toàn ngu ngốc, không có quyền truy cập tới libraries nào cả. Đó là lý do C được dùng trong Linux kernel.<br><br>Nếu bạn thích câu trả lời của tôi, hãy cân nhắc support tui trên patreon. link: https://www.patreon.com/lagdaemon<br><br>1: stateless là không có trạng thái, nghĩa là hàm không phụ thuộc vào state của object, i.e không phụ thuộc vào các properties có thể thay đổi của class.<br><br>2: Là một cơ chế mã hóa tên biến và hàm thành tên duy nhất (unique) để linker* có thể phân biệt những tên thường gặp trong ngôn ngữ (cái này để liên kết các file object được compiler )<br><br>*: thằng này để liên kết các file object lại với nhau khi code đã được compile thành file object.<br><br>Code trong hình do Linus Torvalds viết, remove 1 entry khỏi linked list mà không  cần dùng if, được ông xem là code xịn :D<br><br>ps: Khúc cuối mình dịch không biết đúng hay sai nữa, tại kiến thức còn yếu, ai thấy sai nói mình sửa nhe :D<br><br><img src='https://scontent.fhan17-1.fna.fbcdn.net/v/t1.6435-9/84660550_200099531184820_6776418121944137728_n.jpg?_nc_cat=108&ccb=1-7&_nc_sid=ca434c&_nc_ohc=JB-cPpJDF8MAX_b8qdM&_nc_ht=scontent.fhan17-1.fna&edm=AFuVL-cEAAAA&oh=00_AfDX4AS7g3w0cUJ92bSN4lQZNd7zZ-WpI84YZJY9WSA2Ng&oe=63D0ADDD'></div>