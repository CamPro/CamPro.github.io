<div>733<br><br>#coding #C #ComputerScience #vmc <br><br>Q: Chuyên gia nói rằng trong C++ tăng bằng ++I sẽ nhanh hơn là I++. Có đúng không vậy? Làm sao bạn có thể giải thích được điều này? <br><br>A: Joe Zbiciak, lập trình từ hồi tiểu học<br><br>==========<br><br>*E hèm*<br><br>Đúng là bạn nên dùng ++i thay vì i++ trong C++ khi tăng biến một cách độc lập, vì cách dùng đầu tiên có thể có chút lợi thế về hiệu suất đấy.<br><br>Tuy vậy, chẳng có gì đảm bảo là *sẽ *nhanh hơn đâu. Thực tế thì, với những trình biên dịch cùng vi xử lý hiện đại, quá trình này *sẽ* chẳng đáng kể là bao đối với hầu hết các ngôn ngữ và kiểu dữ liệu. Điều đó nói lên rằng, có *những *trường hợp mà việc này sẽ tạo ra được sự khác biệt đấy.<br><br>Hãy bắt đầu từ đầu nào: ++i và i++ mang ý nghĩa khác nhau.<br><br>· ++i tăng giá trị biến i và trả về giá trị mới được tính toán.<br><br>· i++ tăng giá trị biến i và trả về giá trị trước đó.<br><br>Trên đây tôi chỉ nói *hơi* giản lược chút thôi. Toán tử ++ thực sự chỉ mang ý nghĩa là tăng khi dùng với những kiểu dữ liệu cơ bản mà thôi. Khi dùng với các object của các lớp, nó sẽ gọi ra một trong hai cách dùng **operator**++ đối với lớp đó. Về mặt ngôn ngữ, nó là một “phép tăng”, dù nó không thực sự cộng thêm một vào thứ gì đấy đâu.<br><br>Trong bất kỳ trường hợp nào, sự khác biệt sẽ xảy ra đối với giá trị trả về sau đó: Liệu đó là giá trị mới đã được tăng hay là giá trị cũ? Đối với i++, trình biên dịch (hoặc **operator**++) sẽ cần phải lưu lại một bản copy của giá trị ban đầu để trả về sau khi tăng biến đó lên. Bản copy đó có thể sẽ có một cái giá kha khá đấy.<br><br>Nếu bạn không sử dụng giá trị được trả về từ phép tăng đó, thì hai cách biểu diễn sẽ gần như là một, bởi chẳng có gì dùng giá trị trả về từ biểu thức đó cả. Trong phần lớn trường hợp, trình biên dịch có thể và sẽ xóa bản copy do i++ chỉ thị nếu bạn không cần tới nó. [Tự ngó đi:](https://godbolt.org/z/_ZUgGg)<br><br> **int** i;<br><br> **void**preinc() { ++i; }<br><br> **void**postinc() { i++; }<br><br>Cả hai hàm này đều tạo ra các đoạn mã giống nhau:<br><br> preinc():<br><br>  add DWORD PTR i[rip], 1<br><br>  ret<br><br> postinc():<br><br>  add DWORD PTR i[rip], 1<br><br>  ret<br><br>Vì thế, đối với những kiểu dữ liệu cơ bản, nếu không dùng giá trị được trả về từ một biểu thức tăng, thì sẽ chẳng có khác biệt gì về hiệu suất liên quan tới việc tăng-trước (pre-increment) hay tăng-sau (post-increment).<br><br>Nhưng còn những loại object khác thì sao?<br><br>Các container và thuật toán của C++ đều phụ thuộc vào một khái niệm khá giống pointer có tên là *iterator*. Iterator cho phép bạn duyệt qua dữ liệu theo một cách có thứ tự. Đó là một phép trừu tượng hóa (abstraction) trên cả pointer.<br><br>Ví dụ, iterator cho phép bạn sử dụng các biểu thức như *i++ để truy cập vào một object trong một container và chuyển tới object tiếp theo.  ++ ở đây không đơn giản là “cộng thêm 1” đâu. Trong  std::map, nó cần phải duyệt qua một Rb-tree đó (Red-black tree).<br><br>Do vậy, với iterator, bạn có thể thấy sự khác biệt lớn giữa i++ và ++ivì những chi phí từ việc copy một iterator không phải nhỏ. Và, nếu copy-constructor (hàm tạo sao chép) đối với iterator có hiệu ứng lề (*side effect*), trình biên dịch có thể không tối ưu được nó nữa.<br><br>[Ví dụ:](https://godbolt.org/z/DwXTBS)<br><br>#include <atomic><br><br> **class**clown {<br><br>  **static** std::atomic_ullong allocations;<br><br>  **int** value;<br><br>  **public**:<br><br>  clown() : value(0) { allocations++; }<br><br>  clown(**const** clown& rhs) : value(rhs.value) {<br><br>  allocations++;<br><br>  }<br><br>  clown& **operator**= (**const** clown& rhs) {<br><br>  value = rhs.value;<br><br>  allocations++;<br><br>  }<br><br>  // pre-increment:<br><br>  clown& **operator**++() { value++; **return** ***this**; }<br><br>  // post-increment:<br><br>  clown& **operator**++(**int**) {<br><br>  clown tmp = ***this**;<br><br>  **operator**++(); // implement in terms of pre-increment<br><br>  **return** tmp;<br><br>  }<br><br> };<br><br> clown car;<br><br> **void**preinc() { ++car; }<br><br> **void**postinc() { car++; }<br><br>Lưu ý rằng post-increment được thực hiện giống như pre-incremeent, và thêm bước copy để lưu lại giá trị ban đầu. [Đây là cách thực hiện post-increment thông thường.](https://en.cppreference.com/w/cpp/language/operators#Increment_and_decrement)<br><br>Giờ thì preinc() và postinc() sẽ được viết khác nhau:<br><br> preinc():<br><br>  add DWORD PTR car[rip], 1<br><br>  ret<br><br> postinc():<br><br>  **lock** add QWORD PTR _ZN5clown11allocationsE[rip], 1<br><br>  add DWORD PTR car[rip], 1<br><br>  ret<br><br>Để ý thấy **lock** add không? Đó là vì atomic increment trong copy constructor đấy. Copy constructor đó được gọi trong **operator**++(**int**) (post-increment đó), do ta cần tạo một bản copy của object để trả về sau khi tăng.<br><br>Tất nhiên, đây là một trường hợp được vẽ ra từ trước. Nhưng thực tế là: Thi thoảng, việc copy có thể rất tốn kém, và không phải lúc nào trình biên dịch cũng loại bỏ việc đó được. i++ sẽ ngầm tạo ra bản copy còn ++i thì không.<br><br>Trình biên dịch sẽ loại bỏ những đoạn dead code nó có thể, và vì thế trong phần lớn thời gian, bạn sẽ không cảm nhận được sự khác biệt giữa ++i và i++ đối với các phép tăng độc lập đâu. Dẫu vậy, khi bắt đầu làm việc với iterator hay các object khác, bạn sẽ cảm nhận được chút chênh lệch về hiệu suất đấy.<br><br>[[LINK]](https://www.quora.com/Gurus-say-in-C-incrementing-with-I-is-faster-than-with-I-Is-it-true-How-could-you-explain-this/answer/Joe-Zbiciak)<br><br><img src='https://scontent.fhan17-1.fna.fbcdn.net/v/t1.6435-9/67343048_2410382579208296_7895071504130375680_n.jpg?stp=dst-jpg_s720x720&_nc_cat=102&ccb=1-7&_nc_sid=ca434c&_nc_ohc=6KBj3ytCyTAAX-5h4WW&_nc_ht=scontent.fhan17-1.fna&edm=AFuVL-cEAAAA&oh=00_AfDMyeK26VrMxYyjP_UWNDIxCJGatug3JUkYC0nXHK_3pw&oe=63D0D0CF'></div>