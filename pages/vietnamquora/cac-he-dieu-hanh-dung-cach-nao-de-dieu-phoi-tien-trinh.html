<div># **Các hệ điều hành dùng cách nào để điều phối tiến trình?**<br><br>#computer_science #operating_system #Wednonquora<br><br>Khi ta viết một chương trình nào đó, nó mới chỉ đơn giản là những đoạn code nằm trên ổ cứng. Chỉ khi ta chạy chúng, những đoạn lệnh ấy mới thực sự làm việc với CPU, bộ nhớ... Ta gọi đó là những tiến trình (process).<br><br>Hệ điều hành suy cho cùng cũng là một phần mềm, chẳng qua nó có quyền to hơn các phần mềm thông thường, và có quyền cho phép các phần mềm khác chạy theo cách mà nó quyết định.<br><br>Ví dụ, bạn là người xếp hàng đi bệnh viện. Hàng người đang đứng giống như hàng đợi tiến trình. Bác sĩ trong phòng là CPU, còn cô điều dưỡng mà gọi số giống như OS vậy. Ví dụ cô ấy đọc tên bạn Mai Trường Sơn, thương binh, được ưu tiên, cho vào trước; hoặc Đặng Huy chờ kết quả, cô ấy mời đi ra để cho Vân Anh đến lượt vào phòng... Những hành động cơ cấu để ai khám trước, khám sau, khám bao lâu ấy, giống như việc điều phối tiến trình.<br><br>Nói chung, việc điều phối tiến trình phải đảm bảo sự công bằng, tiến trình nào cũng được thực thi, bởi CPU thì chỉ có một, mà thằng nào cũng muốn được dùng. Ngoài ra, biểu hiện của nó ra phía người dùng là tốc độ phản hồi, sự mượt mà, tốc độ chạy của phần mềm, v.v... Chẳng hạn, người dùng MacOS cảm thấy sự mượt mà hơn Windows, một phần cũng do thuật toán điều phối tiến trình của 2 hệ điều hành này là khác nhau.<br># Một số thuật toán điều phối CPU cơ bản<br><br>[1]<br><br>Trước khi vào phần này, mình xin giải thích 1 số thuật ngữ được Việt hoá mà mình sử dụng:<br><br>**đói **(nguyên văn: **starvation**): tình trạng một tiến trình đợi mãi mà không được dùng tài nguyên, thời gian chờ có thể là vô hạn.<br><br>**trưng dụng **(nguyên văn: **preemptive**):** **một tiến trình đang làm việc với tài nguyên, bị buộc phải nhường lại cho tiến trình khác, gọi là trưng dụng tài nguyên. Nghe bất công nhỉ?<br><br>Tương tự, ta có **không trưng dụng **(nguyên văn: **non-preemptive**): tiến trình nào đang chạy thì chạy hết mới trả lại tài nguyên.<br>## 1. first come first serve (FCFS)<br><br>Đúng như cái tên, đơn giản thằng nào đến trước thì được chạy trước.<br>* Dùng hàng đợi FIFO<br>* Không trưng dụng<br>* Dễ hiểu, dễ cài đặt<br>* Hiệu năng kém, thời gian chờ đợi lâu<br>## 2. Shortest job next (SJN)<br><br>Thuật toán này còn được gọi là Shortest Job First (SJF). Ưu tiên gọi những tiến trình mà thời gian cần dùng CPU còn lại là ngắn nhất (tức là sắp hoàn thành nhất).<br>* Dùng hàng đợi ưu tiên với độ ưu tiên là thời gian còn lại<br>* Dễ hiểu, dễ cài đặt<br>* Không trưng dụng<br>* Giảm thời gian chờ đợi<br>* Có thể gây ra đói CPU: nếu nhiều tiến trình mới có thời gian cần thực hiện ngắn, thì tiến trình có thời gian lâu hơn sẽ bị đẩy vô hạn xuống cuối hàng đợi<br>* Cần biết trước thời gian cần để tiến trình đó hoàn thành<br>## 3. Hàng đợi ưu tiên (Priority Based Scheduling)<br><br>Mỗi tiến trình được gán cho 1 số chỉ độ ưu tiên. Độ ưu tiên cao thì được thực hiện trước, cùng độ ưu tiên thì FCFS.<br>* Không trưng dụng<br>* Độ ưu tiên được xét theo chi phí bộ nhớ, thời gian, hoặc đơn giản là "con ông cháu cha" thì được ưu tiên hoy<br>* Có thể gây ra đói CPU: tiến trình mới đến có độ ưu tiên cao hơn thì tiến trình có độ ưu tiên thấp có khả năng bị chờ vô hạn<br>## 4. Shortest remaining time (srt)<br><br>Y hệt SJN, nhưng có trưng dụng: thằng mới đến mà có thời gian ngắn hơn thời gian thằng đang thực thi thì cũng chiếm luôn CPU.<br>* Có trưng dụng<br>* Phù hợp với hệ thống ưu tiên độ phản hồi của những tiến trình ngắn<br>## 5. Round robin (RR)<br><br>Thuật toán này giống kiểu chơi gangbang CPU ấy, ai cũng được một lát rồi đến người tiếp theo, đảm bảo sự công bằng tối đa.<br>* Có trưng dụng<br>* Các tiến trình mới đến được thêm vào cuối của hàng đợi vòng tròn<br>* Một tiến trình chỉ được dùng tối đa liên tiếp một khoảng thời gian nhất định gọi là **quantum**<br>* Hết một quantum, nếu chưa xong, nó sẽ lưu lại trạng thái và bị tiến trình kế tiếp trưng dụng, và quay xuống cuối hàng đợi, đợi đến vòng tiếp theo<br>* Nếu chưa hết quantum mà đã "ra" rồi, thì nhường CPU cho tiến trình kế tiếp<br>* Công bằng, không bị đói. Có thể xác định trước trường hợp xấu nhất mà một tiến trình phải chờ đợi là bao lâu<br>* Giảm thời gian chờ, tăng tốc độ phản hồi so với FCFS<br>* Hiệu năng phụ thuộc rất nhiều vào việc chọn quantum cho phù hợp (thường tính bằng milisecond)<br>## 6. Hàng đợi nhiều tầng (Multiple-Level Queues Scheduling)<br><br>Đây không phải thuật toán nhất định nào đó, mà nó phép kết hợp các thuật toán trên lại một cách hợp lý. Có nhiều hàng đợi khác nhau được đánh độ ưu tiên, mỗi hàng đợi có thể dùng FCFS, SJN hay RR, tuỳ đặc tính và nhu cầu. Hệ điều hành sẽ chọn tiến trình một cách phù hợp, chuyển tiến trình này sang một hàng đợi khác khi cần v.v...<br># Tổng kết<br><br>Trên đây chỉ là các thuật toán cực kỳ cơ bản, dùng để xây dựng nên các thuật toán được sử dụng trong thực tế.<br><br>Bạn thắc mắc hệ điều hành mình đang dùng sử dụng thuật toán nào? Chà, chắc chỉ có ông nào leak code ra thì mới biết được chính xác! Nhưng ta có thể biết được về cơ bản nó được phát triển từ thuật nào nào trong 6 cái trên.<br><br>Chẳng hạn, hệ điều hành Windows chủ yếu xây dựng trên thuật toán Round Robin, tuy nhiên nó được nâng lên một tầm cao mới, đảm bảo cho người dùng tình trạng giật lag và not responding rất thường xuyên.<br><br>Nhiều hệ điều hành còn sử dụng AI, phân tích thói quen của người dùng, điều chỉnh độ ưu tiên, thay đổi quantum cho phù hợp tình hình... [2]<br><br>Giả sử bạn đang tự xây một hệ điều hành cho riêng mình, bạn sẽ chọn thuật toán nào? Bạn muốn ưu tiên cho phần mềm chạy thật nhanh và liền mạch, hay ưu tiên cho các thao tác được phản hồi mượt mà?<br><br>Hay bạn không quan tâm lắm, tập trung xây dựng UI/UX và kệ moẹ đám tiến trình (xây dựng hoàn toàn trên kernel có sẵn chẳng hạn).<br><br>-----<br><br>Mình đang ôn bài thôi ạ, mấy hôm nữa mình thi môn này, viết cái này để ôn lại xíu :3<br><br>Nguồn: <br><br>[1] [https://www.tutorialspoint.com/operating_system/os_process_scheduling_algorithms.htm](https://www.tutorialspoint.com/operating_system/os_process_scheduling_algorithms.htm)<br><br>[2]<br><br>[https://pdfs.semanticscholar.org/8d73/52c3063fa079eaf0b3b5ae4e990ae4eddaa1.pdf](https://pdfs.semanticscholar.org/8d73/52c3063fa079eaf0b3b5ae4e990ae4eddaa1.pdf)<br><br>**Bùi Thanh Lâm**<br><br><img src='https://scontent.fhan17-1.fna.fbcdn.net/v/t1.6435-9/107673669_1592277064265572_7748468811682009329_n.jpg?_nc_cat=107&ccb=1-7&_nc_sid=ca434c&_nc_ohc=lxWo3ybavjQAX9J6Hzg&_nc_ht=scontent.fhan17-1.fna&edm=AFuVL-cEAAAA&oh=00_AfCRuRVCdLKT1xuvaL49xDwH8NSWX6ihOorpTE0tvQRB9A&oe=63D0B496'></div>