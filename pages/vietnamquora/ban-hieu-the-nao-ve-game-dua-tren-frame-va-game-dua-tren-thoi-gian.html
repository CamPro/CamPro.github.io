<div># **Bạn hiểu thế nào về game dựa trên frame và game dựa trên thời gian?**<br><br>#Wednonquora #game #code #Phaser #JavaScript<br><br>[Dịch từ blog https://www.emanueleferonato.com<br><br> Tác giả: Emanuele Feronato, viết ngày 15/12/2018<br><br> Link bài viết gốc: https://www.emanueleferonato.com/2018/09/15/understanding-frame-based-vs-time-based-games/<br><br> Dịch: Bùi Thanh Lâm]<br><br>Thông thường, khi chúng ta viết một game, sẽ luôn có một cái gì đó được gọi ở mỗi frame (khung hình), để cập nhật khung cảnh được hiển thị. Tưởng tượng như có một cái sân khấu, nhân vật của chúng ta sẽ chuyển động qua từng frame. Các nhân vật này có tốc độ, và chúng di chuyển theo các hướng nhất định, bản chất là một lượng pixel nào đó, qua mỗi frame. Cùng tìm hiểu ví dụ về game ‘Đường tròn bất tận’ phiên bản giản lược sau đây.<br><br>[[Code 1 – JS](https://pastebin.com/EGq5cwq5)]<br><br>Tốc độ của trò chơi được thiết lập tại dòng 5. Với tốc độ là 1, ta cần 360 frame để đi hết vòng tròn.<br><br>[Video 1]<br><br>Như vậy, nếu trình duyệt chạy 60 frame mỗi giây (FPS), bạn sẽ cần 360/60 = 6 giây để đi hết vòng tròn. Giả sử đây là tốc độ mà bạn thấy vừa lòng, vậy bạn sẽ code với suy nghĩ mặc định rằng “hết 6s để đi hết vòng tròn”, coi như trình duyệt render đủ 60 khung hình mỗi giây. Vậy, nếu vì một lý do nào đó bị lag, hoặc trình duyệt render nhanh hơn 60 FPS thì sao? Xem đoạn code dưới đây.<br><br>[[Code 2 – JS](https://pastebin.com/FhwUxvsV)]<br><br>Để ý dòng số 37, ở đây tôi mô phỏng lag bằng cách bỏ qua 1 số frame ngẫu nhiên. Game chơi giờ sẽ kiểu như:<br><br>[Video 2]<br><br>Mất bao lâu để đi hết vòng tròn? Vẫn 6s á? Không, hơn nhiều. Bởi chúng ta cập nhật khung cảnh cho game mỗi frame, nên nếu FPS giảm, thì game sẽ bị chậm hơn.<br><br>Vậy thì đừng giảm FPS nữa là được chứ gì?<br><br>Trong điều kiện lý tưởng, các thiết bị sẽ render khung hình game của chúng ta theo một chỉ số FPS nhất định, khổng bị ảnh hưởng bởi các yếu tố khác. Tuy nhiên, hãy thực tế hơn một chút. Nhất định phải tìm ra cách khắc phục điều này. Đó là xử lý game dựa trên thời gian. Xem đoạn code sau đây.<br><br>[[Code 3 – JS](https://pastebin.com/eehbPjXH)]<br><br>Ở dòng 5, tốc độ không còn được định nghĩa bởi số đo góc/frame nữa, mà là số mili giây cần thiết để đi hết vòng tròn lớn. Vẫn là 6 giây thôi. <br><br>Rồi đến dòng 36, ta sẽ truyền vào 2 tham số, đại diện cho tương ứng là số mili giây từ khi game bắt đầu, và số mili giây từ khi frame gần nhất được render. (ND: để hiểu rõ hơn đoạn này, xem thêm về cú pháp hàm update tại [đây](https://photonstorm.github.io/phaser3-docs/Phaser.Scene.html#update). Đây là một hàm của Phaser, một framewwork được tác giả sử dụng trong phần lớn cả blog này của mình)<br><br>Dòng 37 để tính số đo góc mà vòng tròn nhỏ sẽ di chuyển theo thời gian đã định trước (6s). Kết quả là:<br><br>[Video 3]<br><br>Vòng tròn nhỏ vẫn sẽ mất 6s để đi hết vòng tròn lớn. Giờ ta sẽ thêm một vài lag mô phỏng:<br><br>[[Code 4 – JS](https://pastebin.com/TPCFYKGq)]<br><br>Dòng 35, ta cần một thuộc tính lastUpdate để lưu lại lần update gần nhất kể từ khi game bắt đầu, tính bằng mili giây. Dòng 37, giờ chỉ truyền vào số mili giây kể từ lúc game bắt đầu. Tôi đang mô phỏng lag, nên không cần lấy số mili giây kể từ frame cuối được render nữa. Dòng 39 và 40 sẽ tính số mili giây kể từ frame gần nhất mà được hiển thị (tức không bị lag), sau đó update thời điểm hiện tại vào thuộc tính lastUpdate. Kết quả là:<br><br>[Video 4]<br><br>Đó, game vẫn bị lag, nhưng thời gian để quay hết vòng tròn vẫn là 6s. Game sẽ không bị chậm đi, chẳng qua nó bị giảm FPS thôi. Đây mới là cách bạn điều khiển nhân vật của mình. Tải hết đống code này để nghịch thêm tại [đây](https://www.emanueleferonato.com/wp-content/uploads/2018/09/framevstime/framevstime.zip).<br><br>------------<br><br>(ND:<br><br>Đa phần các game giờ được code theo kiểu 2 cả thôi. Chẳng hạn mạng lag lag một chút, lúc quay lại nhân vật của bạn đã chết rồi; chứ nó không chậm chung cả game như kiểu dựa trên frame.<br><br>Mọi người nên đọc bài viết gốc để trực quan hơn.)<br><br></div>