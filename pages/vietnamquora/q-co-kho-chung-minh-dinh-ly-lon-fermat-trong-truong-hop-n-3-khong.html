<div>586<br><br>#*math *#*FermatLastTheorem *#*vmc*<br><br>Q: Có khó chứng minh Định lý Lớn Fermat trong trường hợp *n *= 3 không?<br><br>Trans: <br><br>- Một bản PDF được mình viết bằng LaTeX rất đẹp có ở [[ĐÂY]](https://drive.google.com/file/d/1xZesc3SJ1QgkXzCKmPgDi0TqPBUoEuly/view)<br><br>Disclaimer:<br><br>- Bài dài, không quá khó nhưng cần kiên nhẫn một chút mới thấm được<br><br>- Nhiều công thức toán không trình bày được ở trên FB này. Bạn tải bản PDF nhìn sẽ rõ hơn.<br><br>- Kiến thức phổ thông không đủ để giải quyết bài toán này nhưng tác giả đã bổ sung rất đầy đủ những phần bổ trợ cần thiết rồi.<br><br>- Cầm bút và giấy bên cạnh, làm những ví dụ nhỏ tác giả đưa ra trong khi đọc sẽ dễ hiểu chứng minh hơn hơn<br><br>Have fun (as I have had)!!!<br><br>A: Alon Amit, Tiến sĩ toán học; nghiện toán. <br><br>L: 5000 word<br><br>[Link.](https://www.quora.com/Is-it-difficult-to-prove-Fermats-Last-Theorem-for-case-n-3/answer/Alon-Amit)<br><br>==========<br><br>“Khó” với kẻ nào chỉ đứng nhìn mà thôi.<br><br>“Định lý Fermat Lớn” (Fermat’s Last Theorem - FLT) đối với lũy thừa bậc 3 nói rằng phương trình<br><br>*a^*3 + *b^*3 = *c^*3<br><br>không có nghiệm khác không nào cả. Đó sẽ là một câu đố rất khó đối với phần lớn học sinh trung học, kể cả là những cô cậu từng thi các kỳ thi như IMO (trans - Olympic toán quốc tế). Không dễ để giải theo cách cơ bản, và bạn có thể thấy điều đó từ độ dài vô lý của câu trả lời Quora này.<br><br>Tuy nhiên, những chứng minh của Định lý này đã có khoảng hơn 200 năm nay rồi, và bạn có thể thấu hiểu được nó không mấy khó khăn nếu đã có những kiến thức nền cơ bản. Chúng được coi là kiến thức cơ bản trong chứng minh toán học và mỗi sinh viên lý thuyết số thực thụ nào cũng phải có khả năng hiểu được điều đó và thậm chí còn có thể tự mình chứng minh được từ con số không nếu cần thiết.<br><br>Tôi sẽ không gọi đây là một định lý kiểu “dễ thấy” đâu nhé: Ngay cả khi đã có được đầy đủ kiến thức về lý thuyết số đại số, mọi thứ vẫn hơi phức tạp chút đấy. Nhưng tôi cũng sẽ không bảo rằng đây là bài toán “khó” nếu mọi quyển sách giáo trình về đề tài này chỉ mất vài trang giấy là chứng minh xong (chứng minh của Wiles về định lý Taniyama-Shimura-Weil, đó mới là cái khó.)<br><br>Đưa chứng minh đó lên Quora này sẽ là một việc hay ho, nên ta chiến thôi nào. Nhưng đầu tiên, nói về lịch sử chút đã.<br><br>————————————–<br><br>Trái với niềm tin của nhiều người thì, Fermat không bao giờ phát biểu “định lý lớn” của mình là *a^n* + *b^n* = *c^n* không có nghiệm khác không khi *n > *2. Ông không tuyên bố trong bài viết hay lá thư nào của mình rằng mình biết cách chứng minh định lý đó. Ghi chú bên lề nổi tiếng nọ (“lề hẹp quá nên tôi không ghi hết ra được”) là do con trai ông công bố sau khi ông mất, và nếu Fermat có thực sự viết ra dòng đó, ông cũng chưa bao giờ nhắc tới nó trước công chúng.<br><br>Ông từng nói tới trường hợp lũy thừa 3 và 4 khá thường xuyên và hay dùng làm đề thách đố những người cùng thời bắt đầu từ khoảng năm 1636. Chúng ta không biết được rằng liệu ông có biết cách chứng minh trường hợp *n *= 3 hay không. Ông đã công bố chứng minh cho *n *= 4, hóa ra trường hợp này dễ hơn nhiều. Lịch sử hay ho về những hiểu nhầm liên quan tới sự ra đời của FLT có lẽ nằm ngoài phạm vi câu hỏi này, nhưng bạn có thể đọc được một vài điểm đáng chú ý ở đây.<br><br>Dù thế nào chăng nữa, Fermat cũng không phải là người đầu tiên (trong những trích dẫn) xem xét phương trình *a^3* + *b^3* = *c^3*, nhưng rõ ràng ông đã làm nó trở nên nổi tiếng.<br><br>Người đâu tiên tuyên bố rằng mình đã chứng minh được định lý đó là Euler. Từ năm 1753 (trong một lá thư gửi đề ngày 4 tháng 8) Goldbach, ông đã nói rằng mình chứng minh được rồi[1], nhưng ấn bản đầu tiên của ông về bài toán này là cuốn “Vollst¨andige Anleitung zur Algebra” in vào năm 1770, và vẫn chưa được hoàn thiện. Nhiều người trong ngành tin rằng ông đã chứng minh được định lý một cách hoàn chỉnh (những chỗ còn thiếu có thể được bù đắp bằng những kết quả trong bài báo năm 1760 của ông), hoặc ít nhất, ông cũng tự chứng minh được nếu như có ai đó chỉ rõ những thiếu sót cho ông.<br><br>Khi tôi đang viết câu trả lời này, [mục Wikipedia](https://en.wikipedia.org/wiki/Proof_of_Fermat's_Last_Theorem_for_specific_exponents) thảo luận về chứng minh của FLT đã có trường hợp *n *= 3 nhờ tham khảo “Một bổ đề quan trọng” chưa được chứng minh, và đây cũng chính là thiếu sót trong chứng minh năm 1770 của Euler. Ta có thể khắc phục điều này bằng cách phân tích cẩn thận dạng bậc hai *X^2* +3*Y^2*, nhưng trong chứng minh mà tôi sắp trình bày, tôi sẽ sử dụng một cách tiếp cận hiện đại hơn, khá giống với chứng minh của Gauss.<br><br>Và cũng nên nói rằng, Gauss không khoái FLT lắm đâu. Trong lá thư gửi Olbers năm 1816 ông đã viết (xem Ribenboim[4]):<br><br>Tôi thừa nhận rằng với tư cách một mệnh đề độc lập thì định lý Fermat không khiến tôi cảm thấy hứng thú cho lắm, bởi tôi có thể đưa ra rất nhiều mệnh đề tương tự và người ta chẳng thể chứng minh hay loại bỏ được.<br><br>Tôi nghĩ rằng sinh viên hiện đại cần phải hiểu được điều này. FLT, tự bản thân nó ("với tư cách một mệnh đề độc lập") thực sự khiến người ta mất hứng. Tất nhiên, danh tiếng của nó khiến nhiều nhà toán học tài năng sẵn sàng chinh phục nó, từ đó họ sẽ phát triển được rất nhiều những lý thuyết quan trọng có thể ứng dụng để giải quyết vô số các bài toán và tạo ra được ngành lý thuyết số hiện đại. Được rồi, nói chuyện cũ thế thôi. Sắn tay lên nào.<br><br>————————————–<br># Đại cương<br><br>Cách tiếp cận rất phổ thông trong lý thuyết số. Ta có một phương trình có bậc cao bằng tổng của nhiều số:<br><br>*X^n* = *A *+ *B *+ *C *+ *...*<br><br>Ta sẽ cố phân tích về phải để nó trở thành tích chứ không phải tổng nữa. *X^n* = *F *· *G *· *H ...*<br><br>Sau đó, chúng ta sẽ chứng minh rằng *F,G,H, *nguyên tố cùng nhau, và từ đó chính mỗi số sẽ phải là một lũy thừa bậc n. Hóa ra đây lại là một yêu cầu rất quan trọng để từ đó ta kết luận rằng hoặc phương trình vô nghiệm hoặc có thể tìm được một lời giải nhỏ của phương trình ban đầu. Thực vậy, do ta cố gắng chỉ ra rằng chính F là một dạng lũy thừa *xn*, ta cũng có thể biến dổi mọi thứ để có *x^n* = *a *+ *b *+ *c *+ *...*<br><br>một thứ rất giống với phương trình ban đầu nhưng rõ ràng x mang giá trị nhỏ hơn X. Và cứ “giảm liên tục” như vậy, ta sẽ tạo ra được điều mâu thuẫn ở đây: nếu có nghiệm thì phải có nghiệm nào đó với giá trị X nhỏ nhất, mâu thuẫn với giả thiết trước đó. Để thực hiện bước đầu, phân tích vế phải, chúng ta phải chuyển đổi từ những số nguyên trước đó sang một vành số (number ring), một tập các con số phức bao gồm các số nguyên thông thường và thêm vào đó là rất nhiều các con số mới lạ hấp dẫn và trong vành đó, nhiều quy tắc của số học vẫn đúng (dù không phải tất cả).<br><br>Trong trường hợp này, phương trình là<br><br>*X^3* + *Y^3* = *Z^3*<br><br>Tất nhiên, ta có thể viết lại thành<br><br>*Z^3* = *X^3* – *Y^3* = (*X *− *Y *)(*X^2* + *XY *+ *Y^2*)<br><br>đó là phân tích thừa số vế phải từng phần. Euler sử dụng một cách phân tích hơi khác một chút, và từ đó ông còn chưa giải quyết được việc phân tích dạng bậc hai phát sinh ra. Và trong bài này, ta sẽ phân tích hoàn hoàn mọi thứ, bằng cách nói thêm về nghiệm đơn vị bậc ba.<br><br>———–<br># Số nguyên Eisenstein<br><br>Các số phức thường được định nghĩa dưới dạng *a *+ *bi *trong đó *a, b *là các số thực và *i *là một số thỏa mãn *i^2* = −1. Chúng ta sẽ làm một điều gần tương tự bằng cách giới thiệu một số mới *ω *và biểu diễn một tập các các số dưới dạng *a*+*bω *trong đó *a,b *là các số nguyên và *ω *thỏa *ω^3* = 1 nhưng *ω khác *1. Lưu ý: *a,b *giờ là số nguyên chứ không phải là số thực tùy ý nữa.<br><br>Tập hợp tất cả các con số đó tạo thành một vành ta gọi là R . Đó là một “vành” bởi ta có thể cộng, trừ và nhân các con số đó, nhưng có thể không chia được, cũng như các số nguyên Z vậy. Các phần tử của R còn được gọi là các số nguyên Eisenstein để tưởng nhớ Gotthold Eisenstein, một trong những ngôi sao toán học của thế kỷ 19 chẳng thể đón được sinh nhật lần thứ 30 của mình.<br><br>Nếu bạn thoải mái với số phức, bạn có thể coi *ω *là <br><br>*ω = e^(2pi*i/3)*<br><br>Từ đó, các số *a *+ *bω *sẽ trông như vầy, trong mặt phẳng phức:<br><br>[Hình]<br><br>Số nguyên Eisenstein là các chấm xanh, đỏ (đó là những điểm "đơn vị", ngay sau đây ta sẽ nói về điều này). Hãy để ý chấm xanh chỉ điểm 1 − *ω *ở góc phải bên dưới đó. Ta sẽ dùng tới nó rất nhiều lần đấy.<br><br>Để quen với việc dùng các số nguyên Eisenstein, đầu tiên bạn phải lưu tâm tới một tính chất quan trọng của *ω*: *ω^2* + *ω *+ 1 = 0<br><br>Ta có thể suy ra điều này từ vế *ω^3* −1 = 0, và (*ω *−1)(*ω^2* +*ω *+1) = 0. Và vì ta đã quy ước rằng *ω khác* 1, nên có một nhân tử sẽ bị loại trừ. Tất nhiên, nếu bạn coi *ω *là số phức *e^(2pi*i/3)*, bạn có thể chứng minh trực tiếp điều này.<br><br>Tính chất này của *ω *cho phép chúng ta chỉ cần xét *a *+ *bω *là đủ, không cần quan tâm tới những dạng như *a*+*bω*+*cω^2*. Thực vậy, mỗi khi *ω^2* xuất hiện, bạn chỉ cần thay bằng −*ω *− 1 mà thôi.<br><br>Và từ đó, bạn có thể đùa nghịch số nguyên Eisenstein rồi.<br><br>(2 + *ω*) + (3 − 4*ω*) = 5 − 3*ω*<br><br>(5+*ω*)(2−3*ω*) = 10+2*ω*−15*ω*−3*ω^2* = 10−13*ω*+3(*ω*+1) = 13−10*ω*<br><br>Một khi đã quen rồi thì, số nguyên Eisenstein cũng chẳng bí mật hơn những số nguyên thông thường đâu, song trông chúng lại gọn hơn nhiều đấy. Số nguyên chỉ là những chấm nhàm chán cách đều nhau trên đường thẳng số mà thôi, nhưng các số Eisensteins lại là một lưới rất đẹp, đúng không? Ví dụ, đây là các số nguyên tố Eisenstein, định nghĩa ngắn gọn là:<br><br>[hình]<br># Số học trong R<br><br>Từ giờ, khi nói về "số", ta sẽ coi đó là số nguyên Eisenstein, một phần tử của R. Các con số đó có thể cộng, trừ và nhân được với nhau, nên chúng ta có thể sử dụng những tính chất số học chuẩn tắc và cố tìm hiểu xem sẽ có được thứ gì. Ta chỉ cần những tính chất sau thôi. Một vài thứ sẽ khá quen thuộc đó.<br><br>• Nếu *x,y *là các số, ta nói rằng *x *là ước của *y *nếu có số *m *nào đó sao cho *mx *= *y*. Đó chính là định nghĩa đối với các số nguyên thông thường mà bạn đã rất quen rồi đấy. Ta sẽ viết *x*|*y *khi *x *là ước của *y*. Ví dụ, trước đó chúng ta từng thấy rằng (5 + *ω*)|(13 − 10*ω*), và đồng thời (2 − 3*ω*)|(13 − 10*ω*).<br><br>• Ta nói rằng *x *và *y *đồng dư với nhau modulo *m*, ký hiệu là *x *≡ *y *(mod *m*), nếu *m *là ước của *x*−*y*. Và đây lại là định nghĩa được dành cho những số nguyên thường, nhưng giờ đây cả ba số (*x,y,m*) đều có thể trở thành những số “mới”: phần tử của R.<br><br>• Nếu *x*|1, ta nói rằng *x *là một phần tử đơn vị. Ta không thường xuyên nói về những phần tử "đơn vị" ở trường phổ thông, bởi ta thường làm những bài toán đại số liên quan tới số nguyên dương thôi, và do đó, phần tử đơn vị duy nhất chỉ là 1 mà thôi. Nhưng trong tập các số nguyên, ta đã có hai phần tử đơn vị rồi: 1 và −1, và cần phải kể tên chúng ra. Trong hệ thống số mới, ta có sáu phần tử như vậy, nên chúng cần có một cái tên. Ta cũng có thể coi đó là các phần tử khả nghịch của R. Đó là các phần tử duy nhất có số nghịch đảo nhân tích (multiplicative inverse). Bạn nên thử chứng minh rằng 1*,*−1*,ω,*−*ω,*1+ *ω *và −1−*ω *là tất cả những phần tử đơn vị. Và thực tế thì, đó là những phần tử đơn vị duy nhất.<br><br>• Nếu *x*|*y *và *y*|*x*, ta nói rằng *x *và *y *liên đới với nhau, và viết *x *∼ *y*. Khi dạy số học trong trường học, người ta không hay giải thích điều này, bởi vì đối với các số nguyên dương thì chúng chỉ liên đới với nhau khi bằng nhau mà thôi, và rõ ràng đưa ra một định nghĩa khác để nói về những thứ "bằng nhau" là điều ngớ ngẩn. Tuy nhiên, nếu bạn nghĩ về số học trong các số nguyên, bạn sẽ thấy rằng 7|(−7) và (−7)|7, vì thế 7 và −7 cũng liên đới với nhau. Thực tế thì, bạn nên chứng minh rằng *x *chỉ là các tích *xu *của *x *với một phần tử đơn vị *u *nào đó, cũng như liên đới của 7 là tích của 7 với ±1 trong tập các số nguyên thông thường thôi.<br><br>• Ta nói rằng *x *bất khả quy nếu nó không phải là phần tử đơn vị, nhưng tập (những) ước của nó chỉ bao gồm phần tử đơn vị cùng những liên đới của nó. Nói cách khác thì, một số *x *không phải phần tử đơn vị sẽ là số bất khả quy nếu *x *= *yz *tương đương với việc *y *hoặc *z *là phần tử đơn vị, vì thế việc "phân tích" cũng vô ích như thể viết 17 = (−1)(−17) vậy. Cái này nghe sẽ quen hơn này: đây là định nghĩa "nguyên tố" đối với các số nguyên thông thường. Trong lý thuyết vành, thuật ngữ chính xác là bất khả quy, bởi vì "nguyên tố" được định nghĩa theo cách hơi khác một chút. Trong vành này, hai khái niệm đó là tương đương. Vì thế ta sẽ gọi những phần tử bất khả quy là số nguyên tố.<br><br>• Với mỗi số nguyên tố *p *và mỗi số *x*, ta có thể xem xét lũy thừa bậc cao nhất của *p *là ước của *x*, hoặc "số lần" mà *x *có thể chia được cho *p*. Đó được gọi là trị số p (p-valuation) của *x*, ký hiệu là *val_p*(*x*). Đó là một ký hiệu đơn giản song trường trung học thường lược bỏ. Ta thấy rằng 2−*valuation *của 40 là 3 vì 2^3 là ước của 40 nhưng 2^4 thì không. Khi *k *= *val_p*(*x*) ta viết *p^k ||* *x *để ký hiệu rằng *p^k*|*x *nhưng chẳng có lũy thừa bậc cao hơn nào của *p *là ước của *x *nữa. Từ đó, 2^3 || 40.<br><br>• Hai số được gọi là nguyên tố cùng nhau nếu ước chung của chúng chỉ là các phần tử đơn vị. Và thêm một lần nữa, đây chính là định nghĩa mà bạn vẫn dùng ở trường trung học đó.<br><br>• Nếu *x *= *a*+*bω*, ta gọi *x_ =* *a*+*bω*2 = (*a*−*b*)−*bω *là phần tử liên hợp của *x*. Đơn giản thì, đây chỉ là liên hợp phức của *x *mà thôi, và từ đó tích *N*(*x*) = *xx_ *luôn là một số nguyên dương, và được gọi là chuẩn của *x*. Bạn nên tự chứng minh điều này: *N*(*a*+*bω*) = *a*2 −*ab*+*b*2. Chứng minh rằng *N*(*xy*) = *N*(*x*)*N*(*y*), và kết luận rằng các phần tử đơn vị là các số có chuẩn bằng 1, và rằng số có chuẩn là số nguyên tố thì cũng phải là số nguyên tố (Lưu ý: mệnh đề đảo không đúng. Chuẩn của 2 là 4, nhưng 2 vẫn là số nguyên tố trong tập số nguyên Eisenstein).<br><br>• Với hai số bất kỳ *x,y *ước chung lớn nhất (greatest common divisor gcd) là số *d*, ước chung của cả 2 số đó và đồng thời là bội của bất kỳ con số nào có tính chất đó. Từ đó *d*|*x*, *d*|*y *và nếu *e*|*x *và *e*|*y *thì *e*|*d*. Lưu ý rằng từ "lớn nhất" đã thay đổi ngữ nghĩa, từ giá trị chuyển sang việc "trở thành bội của các số kia". Tính chất về độ lớn của số nguyên thông thường cũng có thể áp dụng được với số nguyên Eisenstein bằng cách sử dụng chuẩn (đây là ý nghĩa của "miền Euclid"), nhưng những ước chung lớn nhất cũng có thể được định nghĩa mà không cần dùng tới độ lớn. Đó là một nhận xét hữu ích. Lưu ý rằng tôi đã viết là "một gcd" thay vì "gcd": khi có các phần tử đơn vị cùng các số liên đới, thì gcd sẽ không là duy nhất.<br><br>• Mỗi số đều có thể biểu diễn dưới dạng tích của các số nguyên tố, và về cơ bản thì đó chỉ là một cách mà thôi. Đây là điểm tương đồng với "phân tích thừa số duy nhất" của các số nguyên thường. "Cơ bản" tức là (tất nhiên) bạn có thể đưa các phần tử đơn vị vào việc khai triển nếu muốn, đồng thời còn có thể sắp xếp lại thứ tự của các số nguyên tố đấy. Nếu số *x *nào đó được phân tích thành tích của phần tử đơn vị và các số nguyên tố theo hai cách, sẽ có những số nguyên tố xuất hiện trong cả hai cách, và số lần xuất hiện là như nhau. Chứng minh là có khai triển và tính duy nhất của khai triển không khó đâu nếu dùng khái niệm chuẩn mà ta vừa định nghĩa. Nếu bạn biết đôi chút về lý thuyết vành, bạn sẽ biết R là một miền Euclid (Euclidean domain), và do đó nó là miền lý tưởng cơ bản (principal ideal domain), và theo đó là một miền phân tích thừa số duy nhất (unique factorization domain).<br><br>Cuối cùng, như đã hứa, ta sẽ đặt cho 1−*ω *một cái tên. *λ *= 1−*ω*. Giờ thì hãy thử giải các bài toán sau, cũng dễ thôi:<br><br>• *N*(*λ*) = 3<br><br>• *Λ^2* ∼ 3<br><br>• *λ *là số nguyên tố<br><br>• Mỗi số *x *đồng dư với −1*,*0 hoặc 1 (mod *λ*). Gợi ý nhé: Lấy bất kỳ con số *x *= *a *+ *bω *nào chia cho *λ*, và sau đó tối giản phân số bằng cách nhân cả tử và mẫu với *λ_*. Nếu kết quả nằm trong R, *x *là bội của *λ*. Nếu không thì, ta sẽ có gì nếu cộng hoặc trừ 1 vào *x *nào? Kết quả này tương đương với việc trong tập số nguyên thường, mỗi số đều đồng dư với −1*,*0 hoặc 1 (mod 3) vậy. Trong hệ số mới, *λ *đóng vai trò tương tự với 3.<br><br>• Trong tập số nguyên thường, mỗi số lập phương *x^3* đồng dư với −1*,*0 hoặc 1 modulo 9. Đó là tính chất quan trọng khi muốn hiểu các số lập phương và tổng của chúng. Chứng minh kết quả tương tự với số nguyên Eisenstein: nếu *λ *không là ước của *x *thì *x^3* đồng dư với −1 hoặc 1 modulo *λ^4*.<br><br>• Mặt khác, hãy chứng minh rằng đối với các số nguyên thông thường, phương trình *a^3+b^3* = *c^3* không có nghiệm nếu cả *a,b,c *đều không chia hết cho 3. Hãy sử dụng điều ta vừa chứng minh được về các số lập phương modulo 9 đó. Điều này cũng đồng nghĩa rằng cái "trường hợp đầu tiên" của FLT là tầm thường với *n *= 3.<br><br>• Sở dĩ quan tâm tới *λ *vì ta sẽ phân tích *x^3* + *y^3* thành (*x *+ *y*)(*x *+ *ωy*)(*x *+ *ω^2y*). Giả thiết rằng *x *và *y *nguyên tố cùng nhau, hãy chứng minh rằng số nguyên tố duy nhất là ước của cả *x *+ *y *và *x *+ *ωy *là *λ*. Hãy nhớ rằng trong phần đại cương, ta đang muốn làm các nhân tử nguyên tố cùng nhau, từ đó kết luận rằng mỗi số phải là một số lập phương. Đây là bước quyết định đó.<br># Chứng Minh<br><br>Nếu thế giới này công bằng với chúng ta thì, việc định nghĩa vành R và thấu hiểu tính chất số học của nó từ nãy tới giờ sẽ giúp ta chứng minh được mệnh đề này dễ như đi dạo mà thôi. Nhưng thực tế lại hơi phũ phàng một chút, và việc chứng minh vẫn sẽ khá phức tạp. Nhưng ta vẫn nên nhận thấy rằng từ giớ, ít nhất thì, mọi thứ sẽ tuân theo những điều mà ta đã vạch ra trước đó một cách thường xuyên.<br><br>Đầu tiên, ta sẽ làm bài toán khó hơn một chút. Thay vì chứng minh phương trình *x^3* + *y^3* = z^3 không có nghiệm trong R, ta sẽ chứng minh rằng với bất kỳ phần tử đơn vị *u *nào, phương trình *x^3* + *y^3* = *uz^3* cũng không có nghiệm. Tại sao ta lại đi làm việc này? Khi ta đang "giảm" bài toán đang nghiên cứu xuống một bài toán con thì cần giới thiệu một phần tử đơn vị. Do đó, cách chứng minh có thể không còn đúng nữa nếu ta giới hạn với trường hợp *u *= 1, và sẽ dễ dàng hơn nếu ngay từ đầu ta sử dụng một cách tiếp cận linh hoạt. Rất may là, phương trình phức tạp hơn kia vẫn không có nghiệm, và từ đó ta có thể chứng minh hoàn chỉnh được.<br><br>Bây giờ, giả sử rằng chúng ta có ba số (các số nguyên Eisenstein) *x,y,z *sao cho *x^3* + *y^3* = *uz^3*. Chúng ta có thể giả thiết *x,y *và *z *đôi một nguyên tố cùng nhau: nếu có số nguyên tố nào là ước của hai số thì nó cũng là ước của số thứ ba và từ đó, ta có thể loại bỏ nó đi.<br><br>Nếu *λ *không là ước của *x,y,z*, ta thấy rằng rõ ràng nó cũng chẳng phải ước của phần tử đơn vị *u*, vì thế mọi số trong phương trình này đều bằng ±1 modulo *λ*. Nhưng phương trình ±1 ± 1 = ±1 không có nghiệm, nên ta không quan tâm. *λ *phải là ước của một trong các số *x,y *hoặc *z*, và vì ba số đó đôi một nguyên tố cùng nhau nên nó phải là ước của đúng một số mà thôi. Ta có thể giả thiết rằng đó là *z*, bội của *λ*. Nếu là *x *hay *y*, ta chứng minh tương tự.<br><br>Hãy xem phương trình modulo *λ^4*, ta vừa chỉ ra rằng những số lập phương không phải bội của *λ *sẽ bằng ±1 modulo *λ^4*. Vậy, ta có ±1 ± 1 ≡ *uz^3* (mod *λ^4*)<br><br>Vì *λ *không phải là ước của 2, nên ta có số 0 ở vế trái, và do đó *λ *là ước của *z *với số lần đủ để *z^3* là bội của *λ^4*. Tức là, *λ*2|*z*. Nếu *λ *|| *z *thì *λ^3* là ước của *z^3*.<br><br>Hãy tổng kết lại những thứ ta đã biết nào. Ta có <br><br>*x^3* + *y^3* = *uz^3* và *λ^2*|*z *và *λ *không phải ước của xy.<br><br>Giờ thì, ta có thể sử dụng tính chất chính của vành Eisenstein để phân tích vế trái:<br><br>(*x *+ *y*)(*x *+ *ωy*)(*x *+ *ω^2y*) = *uz^3*.<br><br>Ta có thể dễ dàng kiểm tra lại điều này bằng cách nhân ngược ra nếu<br><br>chưa rõ. Với *t *= *x/y *ta có 1 + *t^3* = (1 + *t*)(1 + *ωt*)(1 + *ω^2t*).<br><br>Nếu một tích của nhiều số là số lập phương, và các số nguyên tố cùng nhau, từng số phải là một số lập phương. Như ta quan sát, các nhân tử trong vế trái có thể không nguyên tố cùng nhau, nhưng số nguyên tố duy nhất là ước của hai trong số đó là *λ*. Bởi vậy, ta muốn đếm xem có tổng cộng bao nhiêu *λ*, và loại chúng ra khỏi phương trình, đồng thời kết luận rằng chỉ còn lại các số lập phương.<br><br>*val_ λ*(*z*) ≥ 2, nên ta có *val_λ*(*z^3*)  ≥ 6. Tức là ít nhất một trong ba nhân tử ở vế trái phải là bội của *λ^2* (tối thiểu đó), và ta sẽ giả thiết rằng đó là nhân tử *x*+*y*. Nếu không phải, chỉ cần thay *y *bằng *ωy *hoặc *ω^2y*. Rất tiện khi *ω *là một phần tử đơn vị.<br><br>Giờ thì, *x*+*ωy *= (*x*+*y*)−*λy*. Vế đầu tiên, *x*+*y*, có *λ*−*valuation *thấp nhất là 2, nhưng vế thứ hai, *λy*, chỉ có thể chia được cho *λ *một lần thôi. Tức là hiệu này chỉ là chia được cho của *λ *một lần mà thôi (ta có được điều này khi thấy rằng một số chia hết cho 17^2 cộng với một số chia hết cho 17 nhưng không chia hết cho 17^2 chỉ chia hết cho 17 mà thôi. Đây là tính chất "siêu metric" của valuation. Điều tương tự cũng đúng với *x*+*ω*2*y*, vì thế mỗi nhân tử này chỉ đóng góp một *λ*, và những phần khác phải tới từ *x *+ *y*. Tổng kết lại, *val_λ*(*x *+ *y*) = 3* val_λ*(*z*) − 2 *val_λ*(*x *+ *ωy*) = 1 *val_λ*(*x *+ *ω^2y*) = 1<br><br>Tách những lũy thừa của *λ *ra, mỗi nhân tử sẽ là một số lập phương. Và những phần tử đơn vị có thể ở bất cứ vế nào. Ta gọi valuation đầu tiên, số lớn nhất là *t*, từ đó ta viết<br><br>A = (x+y) = u_1 (z_0)^3 *λ^t*<br><br>B = (*x *+ *ωy*) = u_2 (x_1)^3 *λ*<br><br>C = (*x *+ *ω^2y*) = u_3 (y_1)^3 *λ*<br><br>Những số mới *x_*1*, y_*1*, z_0* đôi một nguyên tố cùng nhau, và chẳng có số nào là bội của *λ *cả vì ta đã loại bỏ phần *λ *tương ứng ở mỗi vế rồi.<br><br>Giờ, lưu ý rằng:<br><br>*A *+ *Bω *+ *Cω^2* = 0.<br><br>Do 1 + *ω *+ *ω^2* = 0, giờ ta sẽ có<br><br>u_1 (z_0)^3* λ^t + ωu_2 (x_1)^3 λ + ω^2u_3(y_1)^3 λ = 0*<br><br>Và ta có thể loại thêm một lần *λ *nữa:<br><br>u_1 (z_0)^3* λ^(t-1) + ωu_2 (x_1)^3 + ω^2u_3(y_1)^3 * *= 0*<br><br>Và thật bất ngờ, *t*−1 = 3* val_λ*(*z*)−3 là bội của 3. Ta đặt nó là *t*−1 = 3*s*. Đặt *z_*1 = *z_*0*λ^s*, ta có<br><br>u_1 (z_1)^3 + u’_2 (x_1)^3 + u’_3 (y_1)^3 = 0<br><br>(Ta vừa đặt cho *ωu_*2 và *ω^2u_3 * những cái tên mới đấy. Chúng vẫn là phần tử đơn vị thôi). Nhân với nghịch đảo của u’_2, ta có thể sắp xếp lại thành<br><br>(x_1)^3 + v(y_1)^3 = w(z_1)^3<br><br>trong đó *v *và *w *vẫn là phần tử đơn vị. Trông khá giống với phương trình ban đầu nhỉ. Ta mới thêm một phần tử đơn vị vào trước (y_1)^3. Không cần lo nhiều, giản lược phương trình này theo modulo *λ^2 * ta được<br><br>±1 ± *v *≡ 0 (mod *λ^2*)<br><br>(Nhớ rằng *z_*1 vẫn là bội của *λ*), từ đó ta có *v *= ±1 (những phần tử đơn vị khả dụng còn lại không có tác dụng). Chuyển *y_1* thành –*y_1* nếu cần thiết, ta có<br><br>(x_1)^3 + (y_1)^3 = w(z_1)^3<br><br>Đây chính là phương trình ban đầu, nhưng lại hơi khác khi có một phần tử đơn vị khác đứng trước (z_1)^3 (đó là lý do ta muốn chứng minh một định lý tổng quát hơn), và *val_λ*(*z_1*) nhỏ hơn *val_λ*(*z*). Mâu thuân, vì ngay từ đầu, chúng ta thấy rằng bất kỳ phương trình nào như vậy đều có biến thứ ba là bội của (thấp nhất là) *λ*2. Điều này chỉ ra rằng phương trình đó không có nghiệm trong tập số nguyên Eisenstein, và do đó nó không thể có bất kỳ nghiệm nguyên nào, từ đó chứng minh được định lý lớn Fermat trong trường hợp lũy thừa 3. <br><br>ĐPCM!<br>## Thamkhảo<br><br>[1] [Fermat’s last theorem](http://www-gap.dcs.st-and.ac.uk/~history/HistTopics/Fermat's_last_theorem.html)<br><br>[2] [Uber Eulers Beweis des gr[](https://eudml.org/doc/161396)¨](https://eudml.org/doc/161396) [o[](https://eudml.org/doc/161396)ß[](https://eudml.org/doc/161396)en Fermatschen Satzes fu¨r den Exponenten](https://eudml.org/doc/161396) [3.](https://eudml.org/doc/161396)<br><br>[3] [On Euler’s hypothetical proof](https://link.springer.com/article/10.1134)<br><br>[4] [13](https://www.amazon.com/13-Lectures-Fermats-Last-Theorem/dp/0387904328) [Lectures on Fermat’s Last Theorem: Paulo Ribenboim: 9780387904320](https://www.amazon.com/13-Lectures-Fermats-Last-Theorem/dp/0387904328):<br><br>[Amazon.com: Books](https://www.amazon.com/13-Lectures-Fermats-Last-Theorem/dp/0387904328)<br><br>Credit: Quyet Nguyen , anh Ngô Thanh Liêm<br><br><img src='https://scontent.fhan17-1.fna.fbcdn.net/v/t1.6435-9/58714785_2342300639349824_6850964353177354240_n.jpg?_nc_cat=108&ccb=1-7&_nc_sid=07e735&_nc_ohc=PpvWBAnX1ncAX9VedeI&_nc_ht=scontent.fhan17-1.fna&edm=AFuVL-cEAAAA&oh=00_AfDNBuGJNfoai0na6-pvru8PZBZiOqjV3fWc47RVPIhDhQ&oe=63D0DAF9'></div>