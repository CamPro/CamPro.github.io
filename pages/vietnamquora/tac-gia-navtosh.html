<div># **Tìm phần tử cân bằng của một mảng**<br><br>[Tác giả: Navtosh<br><br> Ngày xuất bản: 04/06/2020<br><br> Link: https://link.medium.com/RqwJVgSpI7]<br><br>(ND: Equilibrium index, trong bài này mình xin phép dịch thô thiển là *phần tử cân bằng*)<br><br>**Độ khó**: Trung bình<br><br>**Thường được hỏi tại**: Amazon, Adobe, Hike<br><br>**Ba phương án được đề xuất**:<br>1. Tiếp cận trực tiếp (dùng 2 vòng lặp lồng nhau)<br>1. Sử dụng thêm bộ nhớ (mảng Prefix sum)<br>1. Sử dụng Single Scan<br><br>**Những điều bạn học được qua bài viết này**:<br><br>Đây là một câu hỏi thú vị trong phỏng vấn, giúp bạn hiểu được việc tối ưu bộ nhớ và giải quyết bài toán với single scan. Những bài toán tương tự như này thường được hỏi rất nhiều trong các buổi phỏng vấn đó nhé.<br>## **Bài Toán **<br><br>Viết một chương trình tìm chỉ số của phần tử cân bằng của một mảng. Phần tử cân bằng của một mảng là phần tử mà tổng các phần tử đứng trước nó bằng tổng các phần tử đứng sau nó. (Ảnh 0)<br>## **Cách 1 - Tiếp Cận trực tiếp (với 2 vòng lặp)**<br><br>**Ý tưởng**<br><br>Phương pháp tiếp cận trực tiếp này sử dụng 2 vòng lặp lồng nhau. Vòng lặp bên ngoài chạy từng phần tử của mảng, ở mỗi phần tử ta dùng tiếp một vòng lặp để tính tổng trái và tổng phải, rồi so sánh với nhau, kiểm tra xem có phần tử cân bằng hay không.<br><br>**Code C++ (Ảnh 1)**<br><br>**Đánh giá độ phức tạp thuật toán**<br><br>Độ phức tạp thời gian: O(n^2)<br><br>Độ phức tạp bộ nhớ: O(1)<br>## **Cách 2 - Sử dụng mảng prefix sum**<br><br>**Ý tưởng**<br><br>Ta sẽ sử dụng một mảng prefixSum cũng gồm n phần tử, trong đó phần tử thứ i của prefixSum lưu tổng các giá trị từ đầu mảng đến phần tử thứ i trong mảng gốc.<br><br>leftSum gán bằng 0, rightSum gán bằng prefixSum[n-1]<br><br>Sau đó, chạy một vòng lặp, mỗi lần lặp ta lại trừ rightSum đi một lượng a[i], đồng thời gán leftSum mới bằng prefix[i-1]. Nếu leftSum = rightSum, trả về chỉ số i.<br><br>**Code C++ (Ảnh 2)**<br><br>**Đánh giá độ phức tạp thuật toán**<br><br>Độ phức tạp thời gian: O(n)<br><br>Độ phức tạp bộ nhớ: O(n)<br>## cách 3 - sử dụng thuật toán single scan<br><br>Ý tưởng<br><br>Ta sẽ tính tổng của cả mảng trước. Điểm khác biệt với cách 2 là ở cách 3 này, ta không lưu mảng prefixSum nữa. Thay vào đó, ta cập nhật leftSum và rightSum lần lượt trong từng bước lặp, cụ thể:<br><br>rightSum = rightSum - a[i] (ban đầu rightSum = totalSum)<br><br>Tiếp đó, ta so sánh leftSum và rightSum và trả về chỉ số i. Nếu không thoả mãn, ta tiếp tục:<br><br>leftSum = leftSum + a[i] (ban đầu leftSum = 0)<br><br>và chuyển đến vòng lặp tiếp theo.<br><br>**Code C++ (Ảnh 3)**<br><br>**Đánh giá độ phức tạp thuật toán**<br><br>Độ phức tạp thời gian: O(n)<br><br>Độ phức tạp bộ nhớ: O(1)<br><br>----<br><br>**Các câu hỏi mà nhà tuyển dụng có thể hỏi thêm:**<br>* Có thể dùng bảng băm để giải bài toán này không?<br>* Có trường hợp đặc biệt nào không?<br><br>**Các bài toán khác giúp thực hành thuật toán single scan**<br>* Loại bỏ các phần tử trùng lặp trong mảng<br>* Bài toán chia sô cô la<br>* Sắp xếp mảng tăng giảm xen kẽ<br>* Đếm số mảng con có tổng chẵn<br>* v.v...<br><br>(ND: Các bạn có thể vào bài viết gốc để xem rất nhiều các bài toán tác giả liệt kê, có link leetcode hoặc geeksforgeeks)<br><br>**Chăm cày thuật toán bạn nhớ!**<br><br><img src='https://scontent.fhan17-1.fna.fbcdn.net/v/t1.6435-9/105026595_1585316428294969_2974172854506411163_n.jpg?stp=dst-jpg_s720x720&_nc_cat=103&ccb=1-7&_nc_sid=07e735&_nc_ohc=JGxdFwfSSbgAX9vYFoo&_nc_ht=scontent.fhan17-1.fna&edm=AFuVL-cEAAAA&oh=00_AfBSVtts5nNMD1tYW5GQPKS347QolznEKnMQvSbzrPnnUg&oe=63D0B637'></div>